/*  Metrowerks Standard Library  */

/*  $Date: 1999/02/01 18:10:40 $ 
 *  $Revision: 1.7 $ 
 *  $NoKeywords: $ 
 *
 *		Portions Copyright © 1995-1999 Metrowerks, Inc.
 *		All rights reserved.
 */

/**
 **  valarray
 **/

#ifndef _VALARRAY
#define _VALARRAY

#include <mslconfig>
#include <algorithm>
#include <cmath>

#ifndef RC_INVOKED // hh 971230

#pragma options align=native
#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
	#pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
	namespace std {
#endif

template<class T> class valarray;         //  An array of type  T
class slice;                              //  a BLAS-like slice out of an array
template<class T> class slice_array;
class gslice;                             //  a generalized slice out of an array
template<class T> class gslice_array;
template<class T> class mask_array;       //  a masked array
template<class T> class indirect_array;   //  an indirected array

template<class T> valarray<T> operator* (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator* (const valarray<T>&, const T&);
template<class T> valarray<T> operator* (const T&, const valarray<T>&);

template<class T> valarray<T> operator/ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator/ (const valarray<T>&, const T&);
template<class T> valarray<T> operator/ (const T&, const valarray<T>&);

template<class T> valarray<T> operator% (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator% (const valarray<T>&, const T&);
template<class T> valarray<T> operator% (const T&, const valarray<T>&);

template<class T> valarray<T> operator+ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator+ (const valarray<T>&, const T&);
template<class T> valarray<T> operator+ (const T&, const valarray<T>&);

template<class T> valarray<T> operator- (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator- (const valarray<T>&, const T&);
template<class T> valarray<T> operator- (const T&, const valarray<T>&);

template<class T> valarray<T> operator^ (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator^ (const valarray<T>&, const T&);
template<class T> valarray<T> operator^ (const T&, const valarray<T>&);

template<class T> valarray<T> operator& (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator& (const valarray<T>&, const T&);
template<class T> valarray<T> operator& (const T&, const valarray<T>&);

template<class T> valarray<T> operator| (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator| (const valarray<T>&, const T&);
template<class T> valarray<T> operator| (const T&, const valarray<T>&);

template<class T> valarray<T> operator<< (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator<< (const valarray<T>&, const T&);
template<class T> valarray<T> operator<< (const T&, const valarray<T>&);

template<class T> valarray<T> operator>> (const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> operator>> (const valarray<T>&, const T&);
template<class T> valarray<T> operator>> (const T&, const valarray<T>&);

template<class T> valarray<bool> operator&& (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator&& (const valarray<T>&, const T&);
template<class T> valarray<bool> operator&& (const T&, const valarray<T>&);

template<class T> valarray<bool> operator|| (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator|| (const valarray<T>&, const T&);
template<class T> valarray<bool> operator|| (const T&, const valarray<T>&);

template<class T> valarray<bool> operator== (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator== (const valarray<T>&, const T&);
template<class T> valarray<bool> operator== (const T&, const valarray<T>&);
template<class T> valarray<bool> operator!= (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator!= (const valarray<T>&, const T&);
template<class T> valarray<bool> operator!= (const T&, const valarray<T>&);

template<class T> valarray<bool> operator<  (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator<  (const valarray<T>&, const T&);
template<class T> valarray<bool> operator<  (const T&, const valarray<T>&);
template<class T> valarray<bool> operator>  (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator>  (const valarray<T>&, const T&);
template<class T> valarray<bool> operator>  (const T&, const valarray<T>&);
template<class T> valarray<bool> operator<= (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator<= (const valarray<T>&, const T&);
template<class T> valarray<bool> operator<= (const T&, const valarray<T>&);
template<class T> valarray<bool> operator>= (const valarray<T>&, const valarray<T>&);
template<class T> valarray<bool> operator>= (const valarray<T>&, const T&);
template<class T> valarray<bool> operator>= (const T&, const valarray<T>&);

template<class T> valarray<T> abs (const valarray<T>&);
template<class T> valarray<T> acos(const valarray<T>&);
template<class T> valarray<T> asin(const valarray<T>&);
template<class T> valarray<T> atan(const valarray<T>&);

template<class T> valarray<T> atan2(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> atan2(const valarray<T>&, const T&);
template<class T> valarray<T> atan2(const T&, const valarray<T>&);

template<class T> valarray<T> cos  (const valarray<T>&);
template<class T> valarray<T> cosh (const valarray<T>&);
template<class T> valarray<T> exp  (const valarray<T>&);
template<class T> valarray<T> log  (const valarray<T>&);
template<class T> valarray<T> log10(const valarray<T>&);

template<class T> valarray<T> pow(const valarray<T>&, const valarray<T>&);
template<class T> valarray<T> pow(const valarray<T>&, const T&);
template<class T> valarray<T> pow(const T&, const valarray<T>&);

template<class T> valarray<T> sin (const valarray<T>&);
template<class T> valarray<T> sinh(const valarray<T>&);
template<class T> valarray<T> sqrt(const valarray<T>&);
template<class T> valarray<T> tan (const valarray<T>&);
template<class T> valarray<T> tanh(const valarray<T>&);

template<class T>
class valarray
{
public:
	typedef T value_type;

	//  lib.valarray.cons construct/destroy:
	valarray();
	explicit valarray(size_t);
	valarray(const T&, size_t);
	valarray(const T*, size_t);
	valarray(const valarray&);
	valarray(const slice_array<T>&);
	valarray(const gslice_array<T>&);
	valarray(const mask_array<T>&);
	valarray(const indirect_array<T>&);
	~valarray();

	//  lib.valarray.assign assignment:
	valarray<T>& operator=(const valarray<T>&);
	valarray<T>& operator=(const T&);
	valarray<T>& operator=(const slice_array<T>&);
	valarray<T>& operator=(const gslice_array<T>&);
	valarray<T>& operator=(const mask_array<T>&);
	valarray<T>& operator=(const indirect_array<T>&);

	//  lib.valarray.access element access:
	T                 operator[](size_t) const;
	T&                operator[](size_t);

	//  lib.valarray.sub subset operations:
	valarray<T>       operator[](slice) const;
	slice_array<T>    operator[](slice);
	valarray<T>       operator[](const gslice&) const;
	gslice_array<T>   operator[](const gslice&);
	valarray<T>       operator[](const valarray<bool>&) const;
	mask_array<T>     operator[](const valarray<bool>&);
	valarray<T>       operator[](const valarray<size_t>&) const;
	indirect_array<T> operator[](const valarray<size_t>&);

	//  lib.valarray.unary unary operators:
	valarray<T> operator+() const;
	valarray<T> operator-() const;
	valarray<T> operator~() const;
	valarray<T> operator!() const;

	//  lib.valarray.cassign computed assignment:
	valarray<T>& operator*= (const T&);
	valarray<T>& operator/= (const T&);
	valarray<T>& operator%= (const T&);
	valarray<T>& operator+= (const T&);
	valarray<T>& operator-= (const T&);
	valarray<T>& operator^= (const T&);
	valarray<T>& operator&= (const T&);
	valarray<T>& operator|= (const T&);
	valarray<T>& operator<<=(const T&);
	valarray<T>& operator>>=(const T&);

	valarray<T>& operator*= (const valarray<T>&);
	valarray<T>& operator/= (const valarray<T>&);
	valarray<T>& operator%= (const valarray<T>&);
	valarray<T>& operator+= (const valarray<T>&);
	valarray<T>& operator-= (const valarray<T>&);
	valarray<T>& operator^= (const valarray<T>&);
	valarray<T>& operator|= (const valarray<T>&);
	valarray<T>& operator&= (const valarray<T>&);
	valarray<T>& operator<<=(const valarray<T>&);
	valarray<T>& operator>>=(const valarray<T>&);

	//  lib.valarray.members member functions:
	size_t size() const;

	T    sum() const;
	T    min() const;
	T    max() const;

	valarray<T> shift (int) const;
	valarray<T> cshift(int) const;
	valarray<T> apply(T func(T)) const;
	valarray<T> apply(T func(const T&)) const;
	void resize(size_t sz, T c = T());

private:
	size_t size_;
	T* data_;

	void change_size(size_t newsize);
};

// valarray Implementation

template<class T>
inline
void
valarray<T>::change_size(size_t newsize)
{
	T* olddata = data_;
	data_ = new T [newsize];
	delete [] olddata;
	size_ = newsize;
}

template<class T>
inline
valarray<T>::valarray()
	: size_(0),
	  data_(0)
{
}

template<class T>
valarray<T>::valarray(size_t n)
	: size_(n),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		fill_n(data_, size_, T());
	}
}

template<class T>
valarray<T>::valarray(const T& t, size_t n)
	: size_(n),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		fill_n(data_, size_, t);
	}
}

template<class T>
valarray<T>::valarray(const T* t, size_t n)
	: size_(n),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		copy(t, t + size_, data_);
	}
}

template<class T>
valarray<T>::valarray(const valarray& v)
	: size_(v.size_),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		copy(v.data_, v.data_ + size_, data_);
	}
}

template<class T>
valarray<T>::valarray(const slice_array<T>& sa)
	: size_(sa.get_slice().length()),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		slice_array<T>::iterator k = sa.begin();
		for (size_t i = 0; i < size_; ++i, ++k)
			data_[i] = *k;
	}
}

template<class T>
valarray<T>::valarray(const gslice_array<T>& gsa)
	: size_(gsa.get_gslice().length()),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		gslice_array<T>::iterator k = gsa.begin();
		for (size_t i = 0; i < size_; ++i, ++k)
			data_[i] = *k;
	}
}

template<class T>
valarray<T>::valarray(const mask_array<T>& ma)
	: size_(ma.length()),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		mask_array<T>::iterator k = ma.begin();
		for (size_t i = 0; i < size_; ++i, ++k)
			data_[i] = *k;
	}
}

template<class T>
valarray<T>::valarray(const indirect_array<T>& ia)
	: size_(ia.length()),
	  data_(0)
{
	if (size_ > 0)
	{
		data_ = new T [size_];
		indirect_array<T>::iterator k = ia.begin();
		for (size_t i = 0; i < size_; ++i, ++k)
			data_[i] = *k;
	}
}

template<class T>
inline
valarray<T>::~valarray()
{
	delete [] data_;
}

template<class T>
valarray<T>&
valarray<T>::operator=(const valarray<T>& v)
{
	if (this == &v)
		return *this;
	if (size() != v.size())
		change_size(v.size());
	copy(v.data_, v.data_ + size_, data_);
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator=(const T& t)
{
	fill_n(data_, size_, t);
	return *this;
}

template<class T>
valarray<T>&
valarray<T>::operator=(const slice_array<T>& sa)
{
	const valarray& v = sa.array();
	if (this == &v)
		return *this = valarray(sa);
	const slice& s = sa.get_slice();
	if (size() != s.length())
		change_size(s.length());
	slice_array<T>::iterator k = sa.begin();
	for (size_t i = 0; i < size_; ++i, ++k)
		data_[i] = *k;
	return *this;
}

template<class T>
valarray<T>&
valarray<T>::operator=(const gslice_array<T>& gsa)
{
	const valarray& v = gsa.array();
	if (this == &v)
		return *this = valarray(gsa);
	const gslice& gs = gsa.get_gslice();
	if (size() != gs.length())
		change_size(gs.length());
	gslice_array<T>::iterator k = gsa.begin();
	for (size_t i = 0; i < size_; ++i, ++k)
		data_[i] = *k;
	return *this;
}

template<class T>
valarray<T>&
valarray<T>::operator=(const mask_array<T>& ma)
{
	const valarray& v = ma.array();
	if (this == &v)
		return *this = valarray(ma);
	if (size() != ma.length())
		change_size(ma.length());
	mask_array<T>::iterator k = ma.begin();
	for (size_t i = 0; i < size_; ++i, ++k)
		data_[i] = *k;
	return *this;
}

template<class T>
valarray<T>&
valarray<T>::operator=(const indirect_array<T>& ia)
{
	const valarray& v = ia.array();
	if (this == &v)
		return *this = valarray(ia);
	if (size() != ia.length())
		change_size(ia.length());
	indirect_array<T>::iterator k = ia.begin();
	for (size_t i = 0; i < size_; ++i, ++k)
		data_[i] = *k;
	return *this;
}

template<class T>
inline
T
valarray<T>::operator[](size_t i) const
{
	return data_[i];
}

template<class T>
inline
T&
valarray<T>::operator[](size_t i)
{
	return data_[i];
}

template<class T>
inline
valarray<T>
valarray<T>::operator[](slice s) const
{
	return slice_array<T>(const_cast<valarray<T>&>(*this), s);
}

template<class T>
inline
slice_array<T>
valarray<T>::operator[](slice s)
{
	return slice_array<T>(*this, s);
}

template<class T>
inline
valarray<T>
valarray<T>::operator[](const gslice& gs) const
{
	return gslice_array<T>(const_cast<valarray<T>&>(*this), gs);
}

template<class T>
inline
gslice_array<T>
valarray<T>::operator[](const gslice& gs)
{
	return gslice_array<T>(*this, gs);
}

template<class T>
inline
valarray<T>
valarray<T>::operator[](const valarray<bool>& b) const
{
	return mask_array<T>(const_cast<valarray<T>&>(*this), b);
}

template<class T>
inline
mask_array<T>
valarray<T>::operator[](const valarray<bool>& b)
{
	return mask_array<T>(*this, b);
}

template<class T>
inline
valarray<T>
valarray<T>::operator[](const valarray<size_t>& ia) const
{
	return indirect_array<T>(const_cast<valarray<T>&>(*this), ia);
}

template<class T>
inline
indirect_array<T>
valarray<T>::operator[](const valarray<size_t>& ia)
{
	return indirect_array<T>(*this, ia);
}

template<class T>
valarray<T>
valarray<T>::operator+() const
{
	valarray result(size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = +data_[i];
	return result;
}

template<class T>
valarray<T>
valarray<T>::operator-() const
{
	valarray result(size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = -data_[i];
	return result;
}

template<class T>
valarray<T>
valarray<T>::operator!() const
{
	valarray result(size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = !data_[i];
	return result;
}

template<class T>
valarray<T>
valarray<T>::operator~() const
{
	valarray result(size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = ~data_[i];
	return result;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator*= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] *= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator/= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] /= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator%= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] %= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator+= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] += t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator-= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] -= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator^= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] ^= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator&= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] &= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator|= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] |= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator<<= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] <<= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator>>= (const T& t)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] >>= t;
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator*= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] *= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator/= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] /= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator%= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] %= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator+= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] += v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator-= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] -= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator^= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] ^= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator|= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] |= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator&= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] &= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator<<= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] <<= v[i];
	return *this;
}

template<class T>
inline
valarray<T>&
valarray<T>::operator>>= (const valarray<T>& v)
{
	for (size_t i = 0; i < size_; ++i)
		data_[i] >>= v[i];
	return *this;
}

template<class T>
inline
size_t
valarray<T>::size() const
{
	return size_;
}

template<class T>
inline
T
valarray<T>::sum() const
{
	T result = T();
	for (size_t i = 0; i < size_; ++i)
		result += data_[i];
	return result;
}

template<class T>
T
valarray<T>::min() const
{
	T result = data_[0];
	for (size_t i = 1; i < size_; ++i)
		if (data_[i] < result)
			result = data_[i];
	return result;
}

template<class T>
T
valarray<T>::max() const
{
	T result = data_[0];
	for (size_t i = 1; i < size_; ++i)
		if (result < data_[i])
			result = data_[i];
	return result;
}

template<class T>
valarray<T>
valarray<T>::shift (int n) const
{
	valarray result(size_);
	size_t start;
	size_t end;
	if (n >= 0)
	{
		start = 0;
		if (n <= size_)
			end = size_ - n;
		else
			end = 0;
	}
	else
	{
		start = size_t(-n);
		end = size_;
	}
	for (size_t i = start; i < end; ++i)
		result[i] = data_[i+n];
	return result;
}

template<class T>
valarray<T>
valarray<T>::cshift(int n) const
{
	valarray result(size_);
	while (n < 0)
		n += (int)size_;
	for (size_t i = 0; i < size_; ++i)
		result[i] = data_[(i + n) % size_];
	return result;
}

template<class T>
valarray<T>
valarray<T>::apply(T func(T)) const
{
	valarray result(size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = func(data_[i]);
	return result;
}

template<class T>
valarray<T>
valarray<T>::apply(T func(const T&)) const
{
	valarray result(size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = func(data_[i]);
	return result;
}

template<class T>
void
valarray<T>::resize(size_t sz, T c)
{
	if (size_ != sz)
		change_size(sz);
	fill_n(data_, size_, c);
}

// slice

class slice
{
public:
	slice();
	slice(size_t start, size_t size, size_t stride);

	size_t start() const;
	size_t size() const;
	size_t stride() const;
	size_t length() const;
private:
	size_t start_;
	size_t size_;
	size_t stride_;
};

// slice Implementation

inline
slice::slice()
	: start_(0),
	  size_(0),
	  stride_(0)
{
}

inline
slice::slice(size_t start, size_t size, size_t stride)
	: start_(start),
	  size_(size),
	  stride_(stride)
{
}

inline
size_t
slice::start() const
{
	return start_;
}

inline
size_t
slice::size() const
{
	return size_;
}

inline
size_t
slice::stride() const
{
	return stride_;
}

inline
size_t
slice::length() const
{
	return size_;
}

// slice_array

template <class T>
class slice_array_iterator
{
public:
	T& operator* ();
	slice_array_iterator& operator++ ();
private:
	size_t stride_;
	T* ptr_;

	slice_array_iterator(const slice_array<T>* sa);

	friend class slice_array<T>;
};

template <class T>
inline
T&
slice_array_iterator<T>::operator*()
{
	return *ptr_;
}

template <class T>
inline
slice_array_iterator<T>&
slice_array_iterator<T>::operator++ ()
{
	ptr_ += stride_;
	return *this;
}

template <class T>
inline
slice_array_iterator<T>::slice_array_iterator(const slice_array<T>* sa)
{
	const slice& s = sa->get_slice();
	stride_ = s.stride();
	ptr_ = &const_cast<slice_array<T>*>(sa)->array()[s.start()];
}

template <class T>
class slice_array
{
public:
	typedef T value_type;

	void operator=  (const valarray<T>&) const;
	void operator*= (const valarray<T>&) const;
	void operator/= (const valarray<T>&) const;
	void operator%= (const valarray<T>&) const;
	void operator+= (const valarray<T>&) const;
	void operator-= (const valarray<T>&) const;
	void operator^= (const valarray<T>&) const;
	void operator&= (const valarray<T>&) const;
	void operator|= (const valarray<T>&) const;
	void operator<<=(const valarray<T>&) const;
	void operator>>=(const valarray<T>&) const;

	void operator=(const T&);
	// ~slice_array();  // uses compiler generated
private:
	slice_array();                              // Not defined
	slice_array(const slice_array&);            // Not defined
	slice_array& operator=(const slice_array&); // Not defined

	typedef slice_array_iterator<T> iterator;

	slice_array(valarray<T>& v, const slice& s);
	const slice& get_slice() const;
	valarray<T>& array();
	const valarray<T>& array() const;
	iterator begin() const;

	valarray<T>& v_;
	slice slice_;

	friend class valarray<T>;
	friend class slice_array_iterator<T>;
};

// slice_array Implementation

template <class T>
void
slice_array<T>::operator= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = v[i];
}

template <class T>
void
slice_array<T>::operator*= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k *= v[i];
}

template <class T>
void
slice_array<T>::operator/= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k /= v[i];
}

template <class T>
void
slice_array<T>::operator%= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k %= v[i];
}

template <class T>
void
slice_array<T>::operator+= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k += v[i];
}

template <class T>
void
slice_array<T>::operator-= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k -= v[i];
}

template <class T>
void
slice_array<T>::operator^= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k ^= v[i];
}

template <class T>
void
slice_array<T>::operator&= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k &= v[i];
}

template <class T>
void
slice_array<T>::operator|= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k |= v[i];
}

template <class T>
void
slice_array<T>::operator<<= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k <<= v[i];
}

template <class T>
void
slice_array<T>::operator>>= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k >>= v[i];
}

template <class T>
void
slice_array<T>::operator=(const T& t)
{
	iterator k = begin();
	size_t end = slice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = t;
}

template <class T>
inline
slice_array<T>::slice_array(valarray<T>& v, const slice& s)
	: v_(v),
	  slice_(s)
{
}

template <class T>
inline
const slice&
slice_array<T>::get_slice() const
{
	return slice_;
}

template <class T>
inline
valarray<T>&
slice_array<T>::array()
{
	return v_;
}

template <class T>
inline
const valarray<T>&
slice_array<T>::array() const
{
	return v_;
}

template <class T>
inline
typename slice_array<T>::iterator
slice_array<T>::begin() const
{
	return iterator(this);
}

// gslice

class gslice
{
public:
	gslice();
	gslice(size_t start, const valarray<size_t>& sizes, const valarray<size_t>& strides);

	size_t start() const;
	const valarray<size_t>& size() const;
	const valarray<size_t>& stride() const;
	size_t length() const;
private:
	size_t start_;
	valarray<size_t> size_;
	valarray<size_t> stride_;
	size_t length_;
};

// gslice Implementation

inline
gslice::gslice()
	: start_(0),
	  length_(0)
{
}

inline
gslice::gslice(size_t start, const valarray<size_t>& sizes, const valarray<size_t>& strides)
	: start_(start),
	  size_(sizes),
	  stride_(strides),
	  length_(0)
{
	if (size_.size() > 0)
	{
		length_ = 1;
		for (size_t i = 0; i < size_.size(); ++i)
			length_ *= size_[i];
	}
}

inline
size_t
gslice::start() const
{
	return start_;
}

inline
const valarray<size_t>&
gslice::size() const
{
	return size_;
}

inline
const valarray<size_t>&
gslice::stride() const
{
	return stride_;
}

inline
size_t
gslice::length() const
{
	return length_;
}

// gslice_array

template <class T>
class gslice_array_iterator
{
public:
	T& operator* ();
	gslice_array_iterator& operator++ ();
private:
	size_t stride_;
	T* start_ptr_;
	const valarray<size_t>* sizes_;
	const valarray<size_t>* strides_;
	valarray<size_t> indices_;
	T* ptr_;

	gslice_array_iterator(const gslice_array<T>* gsa);

	friend class gslice_array<T>;
};

template <class T>
inline
T&
gslice_array_iterator<T>::operator*()
{
	return *ptr_;
}

template <class T>
gslice_array_iterator<T>&
gslice_array_iterator<T>::operator++ ()
{
	size_t i = indices_.size() - 1;
	while (true)
	{
		indices_[i] += 1;
		if (indices_[i] < (*sizes_)[i])
		{
			if (i == indices_.size() - 1)
				ptr_ += stride_;
			else
			{
				ptr_ = start_ptr_;
				for (size_t k = 0; k < indices_.size(); ++k)
					ptr_ += indices_[k] * (*strides_)[k];
			}
			break;
		}
		indices_[i] = 0;
		if (i == 0)
		{
			ptr_ = start_ptr_;
			break;
		}
		--i;
	}
	return *this;
}

template <class T>
gslice_array_iterator<T>::gslice_array_iterator(const gslice_array<T>* gsa)
	: indices_(gsa->get_gslice().size().size())
{
	const gslice& gs = gsa->get_gslice();
	sizes_ = &gs.size();
	strides_ = &gs.stride();
	start_ptr_ = &const_cast<gslice_array<T>*>(gsa)->array()[gs.start()];
	stride_ = (*strides_)[indices_.size()-1];
	ptr_ = start_ptr_;
}

template <class T>
class gslice_array
{
public:
	typedef T value_type;

	void operator=  (const valarray<T>&) const;
	void operator*= (const valarray<T>&) const;
	void operator/= (const valarray<T>&) const;
	void operator%= (const valarray<T>&) const;
	void operator+= (const valarray<T>&) const;
	void operator-= (const valarray<T>&) const;
	void operator^= (const valarray<T>&) const;
	void operator&= (const valarray<T>&) const;
	void operator|= (const valarray<T>&) const;
	void operator<<=(const valarray<T>&) const;
	void operator>>=(const valarray<T>&) const;

	void operator=(const T&);
	// ~gslice_array();  use compiler generated
private:
	gslice_array();                               // Not defined
	gslice_array(const gslice_array&);            // Not defined
	gslice_array& operator=(const gslice_array&); // Not defined

	typedef gslice_array_iterator<T> iterator;

	gslice_array(valarray<T>& v, const gslice& gs);
	const gslice& get_gslice() const;
	valarray<T>& array();
	const valarray<T>& array() const;
	iterator begin() const;

	valarray<T>& v_;
	gslice gslice_;

	friend class valarray<T>;
	friend class gslice_array_iterator<T>;
};

// gslice_array Implementation

template <class T>
void
gslice_array<T>::operator= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = v[i];
}

template <class T>
void
gslice_array<T>::operator*= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k *= v[i];
}

template <class T>
void
gslice_array<T>::operator/= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k /= v[i];
}

template <class T>
void
gslice_array<T>::operator%= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k %= v[i];
}

template <class T>
void
gslice_array<T>::operator+= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k += v[i];
}

template <class T>
void
gslice_array<T>::operator-= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k -= v[i];
}

template <class T>
void
gslice_array<T>::operator^= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k ^= v[i];
}

template <class T>
void
gslice_array<T>::operator&= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k &= v[i];
}

template <class T>
void
gslice_array<T>::operator|= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k |= v[i];
}

template <class T>
void
gslice_array<T>::operator<<= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k <<= v[i];
}

template <class T>
void
gslice_array<T>::operator>>= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k >>= v[i];
}

template <class T>
void
gslice_array<T>::operator=(const T& t)
{
	iterator k = begin();
	size_t end = gslice_.length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = t;
}

template <class T>
inline
gslice_array<T>::gslice_array(valarray<T>& v, const gslice& gs)
	: v_(v),
	  gslice_(gs)
{
}

template <class T>
inline
const gslice&
gslice_array<T>::get_gslice() const
{
	return gslice_;
}

template <class T>
inline
valarray<T>&
gslice_array<T>::array()
{
	return v_;
}

template <class T>
inline
const valarray<T>&
gslice_array<T>::array() const
{
	return v_;
}

template <class T>
inline
typename gslice_array<T>::iterator
gslice_array<T>::begin() const
{
	return iterator(this);
}

// mask_array

template <class T>
class mask_array_iterator
{
public:
	T& operator* ();
	mask_array_iterator& operator++ ();
private:
	size_t i_;
	const valarray<bool>* mask_;
	T* ptr_;

	mask_array_iterator(const mask_array<T>* ma);

	friend class mask_array<T>;
};

template <class T>
inline
T&
mask_array_iterator<T>::operator*()
{
	return *ptr_;
}

template <class T>
inline
mask_array_iterator<T>&
mask_array_iterator<T>::operator++ ()
{
	++i_;
	++ptr_;
	while (!(*mask_)[i_])
	{
		++i_;
		++ptr_;
	}
	return *this;
}

template <class T>
mask_array_iterator<T>::mask_array_iterator(const mask_array<T>* ma)
	: mask_(&ma->mask()),
	  i_(0),
	  ptr_(&const_cast<mask_array<T>*>(ma)->array()[0])
{
	while (!(*mask_)[i_])
	{
		++i_;
		++ptr_;
	}
}

template <class T>
class mask_array
{
public:
	typedef T value_type;

	void operator=  (const valarray<T>&) const;
	void operator*= (const valarray<T>&) const;
	void operator/= (const valarray<T>&) const;
	void operator%= (const valarray<T>&) const;
	void operator+= (const valarray<T>&) const;
	void operator-= (const valarray<T>&) const;
	void operator^= (const valarray<T>&) const;
	void operator&= (const valarray<T>&) const;
	void operator|= (const valarray<T>&) const;
	void operator<<=(const valarray<T>&) const;
	void operator>>=(const valarray<T>&) const;

	void operator=(const T&);
	// ~mask_array();  use compiler generated
private:
	mask_array();                              // Not defined
	mask_array(const mask_array&);             // Not defined
	mask_array& operator=(const mask_array&);  // Not defined

	typedef mask_array_iterator<T> iterator;

	mask_array(valarray<T>& v, const valarray<bool>& mask);
	const valarray<bool>& mask() const;
	valarray<T>& array();
	const valarray<T>& array() const;
	iterator begin() const;
	size_t length() const;

	valarray<T>& v_;
	valarray<bool> mask_;
	size_t length_;
	
	friend class valarray<T>;
	friend class mask_array_iterator<T>;
};

template <class T>
void
mask_array<T>::operator= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = v[i];
}

template <class T>
void
mask_array<T>::operator*= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k *= v[i];
}

template <class T>
void
mask_array<T>::operator/= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k /= v[i];
}

template <class T>
void
mask_array<T>::operator%= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k %= v[i];
}

template <class T>
void
mask_array<T>::operator+= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k += v[i];
}

template <class T>
void
mask_array<T>::operator-= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k -= v[i];
}

template <class T>
void
mask_array<T>::operator^= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k ^= v[i];
}

template <class T>
void
mask_array<T>::operator&= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k &= v[i];
}

template <class T>
void
mask_array<T>::operator|= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k |= v[i];
}

template <class T>
void
mask_array<T>::operator<<= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k <<= v[i];
}

template <class T>
void
mask_array<T>::operator>>= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k >>= v[i];
}

template <class T>
void
mask_array<T>::operator=(const T& t)
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = t;
}

template <class T>
mask_array<T>::mask_array(valarray<T>& v, const valarray<bool>& mask)
	: v_(v),
	  mask_(mask),
	  length_(0)
{
	for (size_t i = 0; i < v.size(); ++i)
		if (mask_[i])
			++length_;
}

template <class T>
inline
const valarray<bool>&
mask_array<T>::mask() const
{
	return mask_;
}

template <class T>
inline
valarray<T>&
mask_array<T>::array()
{
	return v_;
}

template <class T>
inline
const valarray<T>&
mask_array<T>::array() const
{
	return v_;
}

template <class T>
inline
typename mask_array<T>::iterator
mask_array<T>::begin() const
{
	return iterator(this);
}

template <class T>
inline
size_t
mask_array<T>::length() const
{
	return length_;
}

// indirect_array

template <class T>
class indirect_array_iterator
{
public:
	T& operator* ();
	indirect_array_iterator& operator++ ();
private:
	size_t i_;
	const indirect_array<T>* ia_;
	T* ptr_;

	indirect_array_iterator(const indirect_array<T>* ia);

	friend class indirect_array<T>;
};

template <class T>
inline
T&
indirect_array_iterator<T>::operator*()
{
	return *ptr_;
}

template <class T>
inline
indirect_array_iterator<T>&
indirect_array_iterator<T>::operator++ ()
{
	ptr_ = &const_cast<indirect_array<T>*>(ia_)->array()[ia_->ia()[++i_]];
	return *this;
}

template <class T>
inline
indirect_array_iterator<T>::indirect_array_iterator(const indirect_array<T>* ia)
	: i_(0),
	  ia_(ia),
	  ptr_(&const_cast<indirect_array<T>*>(ia)->array()[ia->ia()[0]])
{
}

template <class T>
class indirect_array
{
public:
	typedef T value_type;

	void operator=  (const valarray<T>&) const;
	void operator*= (const valarray<T>&) const;
	void operator/= (const valarray<T>&) const;
	void operator%= (const valarray<T>&) const;
	void operator+= (const valarray<T>&) const;
	void operator-= (const valarray<T>&) const;
	void operator^= (const valarray<T>&) const;
	void operator&= (const valarray<T>&) const;
	void operator|= (const valarray<T>&) const;
	void operator<<=(const valarray<T>&) const;
	void operator>>=(const valarray<T>&) const;

	void operator=(const T&);
	// ~indirect_array();  use compiler generated
private:
	indirect_array();                                  // Not defined
	indirect_array(const indirect_array&);             // Not defined
	indirect_array& operator=(const indirect_array&);  // Not defined

	typedef indirect_array_iterator<T> iterator;

	indirect_array(valarray<T>& v, const valarray<size_t>& ia);
	const valarray<size_t>& ia() const;
	valarray<T>& array();
	const valarray<T>& array() const;
	iterator begin() const;
	size_t length() const;

	valarray<T>& v_;
	valarray<size_t> ia_;
	
	friend class valarray<T>;
	friend class indirect_array_iterator<T>;
};

// indirect_array Implementation

template <class T>
void
indirect_array<T>::operator= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = v[i];
}

template <class T>
void
indirect_array<T>::operator*= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k *= v[i];
}

template <class T>
void
indirect_array<T>::operator/= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k /= v[i];
}

template <class T>
void
indirect_array<T>::operator%= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k %= v[i];
}

template <class T>
void
indirect_array<T>::operator+= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k += v[i];
}

template <class T>
void
indirect_array<T>::operator-= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k -= v[i];
}

template <class T>
void
indirect_array<T>::operator^= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k ^= v[i];
}

template <class T>
void
indirect_array<T>::operator&= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k &= v[i];
}

template <class T>
void
indirect_array<T>::operator|= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k |= v[i];
}

template <class T>
void
indirect_array<T>::operator<<= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k <<= v[i];
}

template <class T>
void
indirect_array<T>::operator>>= (const valarray<T>& v) const
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k >>= v[i];
}

template <class T>
void
indirect_array<T>::operator=(const T& t)
{
	iterator k = begin();
	size_t end = length();
	for (size_t i = 0; i < end; ++i, ++k)
		*k = t;
}

template <class T>
inline
indirect_array<T>::indirect_array(valarray<T>& v, const valarray<size_t>& ia)
	: v_(v),
	  ia_(ia)
{
}

template <class T>
inline
const valarray<size_t>&
indirect_array<T>::ia() const
{
	return ia_;
}

template <class T>
inline
valarray<T>&
indirect_array<T>::array()
{
	return v_;
}

template <class T>
inline
const valarray<T>&
indirect_array<T>::array() const
{
	return v_;
}

template <class T>
inline
typename indirect_array<T>::iterator
indirect_array<T>::begin() const
{
	return iterator(this);
}

template <class T>
inline
size_t
indirect_array<T>::length() const
{
	return ia_.size();
}

// valarray binary operators

template<class T>
valarray<T>
operator* (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] * y[i];
	return result;
}

template<class T>
valarray<T>
operator* (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] * t;
	return result;
}

template<class T>
valarray<T>
operator* (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t * x[i];
	return result;
}

template<class T>
valarray<T>
operator/ (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] / y[i];
	return result;
}

template<class T>
valarray<T>
operator/ (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] / t;
	return result;
}

template<class T>
valarray<T>
operator/ (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t / x[i];
	return result;
}

template<class T>
valarray<T>
operator% (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] % y[i];
	return result;
}

template<class T>
valarray<T>
operator% (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] % t;
	return result;
}

template<class T>
valarray<T>
operator% (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t % x[i];
	return result;
}

template<class T>
valarray<T>
operator+ (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] + y[i];
	return result;
}

template<class T>
valarray<T>
operator+ (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] + t;
	return result;
}

template<class T>
valarray<T>
operator+ (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t + x[i];
	return result;
}

template<class T>
valarray<T>
operator- (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] - y[i];
	return result;
}

template<class T>
valarray<T>
operator- (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] - t;
	return result;
}

template<class T>
valarray<T>
operator- (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t - x[i];
	return result;
}

template<class T>
valarray<T>
operator^ (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] ^ y[i];
	return result;
}

template<class T>
valarray<T>
operator^ (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] ^ t;
	return result;
}

template<class T>
valarray<T>
operator^ (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t ^ x[i];
	return result;
}

template<class T>
valarray<T>
operator& (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] & y[i];
	return result;
}

template<class T>
valarray<T>
operator& (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] & t;
	return result;
}

template<class T>
valarray<T>
operator& (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t & x[i];
	return result;
}

template<class T>
valarray<T>
operator| (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] | y[i];
	return result;
}

template<class T>
valarray<T>
operator| (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] | t;
	return result;
}

template<class T>
valarray<T>
operator| (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t | x[i];
	return result;
}

template<class T>
valarray<T>
operator<< (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] << y[i];
	return result;
}

template<class T>
valarray<T>
operator<< (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] << t;
	return result;
}

template<class T>
valarray<T>
operator<< (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t << x[i];
	return result;
}

template<class T>
valarray<T>
operator>> (const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] >> y[i];
	return result;
}

template<class T>
valarray<T>
operator>> (const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] >> t;
	return result;
}

template<class T>
valarray<T>
operator>> (const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t >> x[i];
	return result;
}

// valarray logical operators

template<class T>
valarray<bool>
operator&& (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] && y[i];
	return result;
}

template<class T>
valarray<bool>
operator&& (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] && t;
	return result;
}

template<class T>
valarray<bool>
operator&& (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t && x[i];
	return result;
}

template<class T>
valarray<bool>
operator|| (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] || y[i];
	return result;
}

template<class T>
valarray<bool>
operator|| (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] || t;
	return result;
}

template<class T>
valarray<bool>
operator|| (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t || x[i];
	return result;
}

template<class T>
valarray<bool>
operator== (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] == y[i];
	return result;
}

template<class T>
valarray<bool>
operator== (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] == t;
	return result;
}

template<class T>
valarray<bool>
operator== (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t == x[i];
	return result;
}

template<class T>
valarray<bool>
operator!= (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] != y[i];
	return result;
}

template<class T>
valarray<bool>
operator!= (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] != t;
	return result;
}

template<class T>
valarray<bool>
operator!= (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t != x[i];
	return result;
}

template<class T>
valarray<bool>
operator<  (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] < y[i];
	return result;
}

template<class T>
valarray<bool>
operator<  (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] < t;
	return result;
}

template<class T>
valarray<bool>
operator<  (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t < x[i];
	return result;
}

template<class T>
valarray<bool>
operator>  (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] > y[i];
	return result;
}

template<class T>
valarray<bool>
operator>  (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] > t;
	return result;
}

template<class T>
valarray<bool>
operator>  (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t > x[i];
	return result;
}

template<class T>
valarray<bool>
operator<= (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] <= y[i];
	return result;
}

template<class T>
valarray<bool>
operator<= (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] <= t;
	return result;
}

template<class T>
valarray<bool>
operator<= (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t <= x[i];
	return result;
}

template<class T>
valarray<bool>
operator>= (const valarray<T>& x, const valarray<T>& y)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] >= y[i];
	return result;
}

template<class T>
valarray<bool>
operator>= (const valarray<T>& x, const T& t)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = x[i] >= t;
	return result;
}

template<class T>
valarray<bool>
operator>= (const T& t, const valarray<T>& x)
{
	valarray<bool> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = t >= x[i];
	return result;
}

// valarray transcendentals

template<class T>
valarray<T>
abs(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(abs(x[i]));
	return result;
}

template<class T>
valarray<T>
acos(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(acos(x[i]));
	return result;
}

template<class T>
valarray<T>
asin(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(asin(x[i]));
	return result;
}

template<class T>
valarray<T>
atan(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(atan(x[i]));
	return result;
}

template<class T>
valarray<T>
atan2(const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(atan2(x[i], y[i]));
	return result;
}

template<class T>
valarray<T>
atan2(const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(atan2(x[i], t));
	return result;
}

template<class T>
valarray<T>
atan2(const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(atan2(t, x[i]));
	return result;
}

template<class T>
valarray<T>
cos(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(cos(x[i]));
	return result;
}

template<class T>
valarray<T>
cosh(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(cosh(x[i]));
	return result;
}

template<class T>
valarray<T>
exp(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(exp(x[i]));
	return result;
}

template<class T>
valarray<T>
log(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(log(x[i]));
	return result;
}

template<class T>
valarray<T>
log10(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(log10(x[i]));
	return result;
}

template<class T>
valarray<T>
pow(const valarray<T>& x, const valarray<T>& y)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(pow(x[i], y[i]));
	return result;
}

template<class T>
valarray<T>
pow(const valarray<T>& x, const T& t)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(pow(x[i], t));
	return result;
}

template<class T>
valarray<T>
pow(const T& t, const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(pow(t, x[i]));
	return result;
}

template<class T>
valarray<T>
sin(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(sin(x[i]));
	return result;
}

template<class T>
valarray<T>
sinh(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(sinh(x[i]));
	return result;
}

template<class T>
valarray<T>
sqrt(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(sqrt(x[i]));
	return result;
}

template<class T>
valarray<T>
tan(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(tan(x[i]));
	return result;
}

template<class T>
valarray<T>
tanh(const valarray<T>& x)
{
	valarray<T> result(x.size());
	for (size_t i = 0; i < result.size(); ++i)
		result[i] = static_cast<T>(tanh(x[i]));
	return result;
}

#ifndef _MSL_NO_CPP_NAMESPACE
	} // namespace std
#endif

#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
	#pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _VALARRAY

// hh 971220 fixed MOD_INCLUDE
// hh 971226 added alignment wrapper
// hh 971226 Changed filename from valarray.h to valarray
// hh 971226 Made include guards standard
// hh 971226 added MSIPLSTD to min in valarray constructor
// hh 971229 Changed the friend declarations to not require member templates
// hh 971229 removed :: from fill_n in fill
// hh 971229 added val_array prototypes
// hh 971229 gslice_array, indirect_array and mask_array moved up in file to avoid "using
//           incomplete type" errors.
// hh 971230 added RC_INVOKED wrapper
// hh 980408 wrapped in #ifndef _No_Floating_Point
// hh 990113 Rewrote
