/*  Metrowerks Standard Library  */

/*  $Date: 1999/01/23 00:25:41 $ 
 *  $Revision: 1.6 $ 
 *  $NoKeywords: $ 
 *
 *		Portions Copyright © 1995-1999 Metrowerks, Inc.
 *		All rights reserved.
 */

/**
 **  set       // hh 971223 Changed filename from set.h to set
 **/

#ifndef _SET
#define _SET

#include <mslconfig>
#include <tree.h>
#include <functional>

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
	#pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
	namespace std {
#endif

// set

template <class Key, class Compare = less<Key>, class Allocator = allocator<Key> >
class set
{
public:
	//  types:
	typedef Key                                   key_type;
	typedef Key                                   value_type;
	typedef Compare                               key_compare;
	typedef Compare                               value_compare;
	typedef Allocator                             allocator_type;
	typedef typename Allocator::reference         reference;
	typedef typename Allocator::const_reference   const_reference;
	class                                         iterator;
	class                                         const_iterator;
	typedef typename Allocator::size_type         size_type;
	typedef typename Allocator::difference_type   difference_type;
	typedef typename Allocator::pointer           pointer;
	typedef typename Allocator::const_pointer     const_pointer;
	typedef _STD::reverse_iterator<iterator>       reverse_iterator;
	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;

private:
	typedef __tree<value_type, value_compare, allocator_type> tree_type;
public:

	struct debug_view
	{
		debug_view* left_;
		debug_view* right_;
		debug_view* parent_;
		value_type data_;
	};

	friend class iterator;
	class iterator
		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>
	{
	public:
		iterator() {}
		const_reference operator * () const {return *i_;}
		const_pointer operator -> () const {return i_.operator->();}
		iterator& operator ++ () {++i_; return *this;}
		iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}
		iterator& operator -- () {--i_; return *this;}
		iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}
		bool operator ==(const iterator& rhs) const {return i_ == rhs.i_;}
		bool operator ==(const const_iterator& rhs) const {return const_iterator(*this) == rhs;}
		bool operator !=(const iterator& rhs) const {return i_ != rhs.i_;}
		bool operator !=(const const_iterator& rhs) const {return  const_iterator(*this) != rhs;}
	private:
		tree_type::iterator i_;

		iterator(const tree_type::iterator& i) : i_(i) {}
		operator tree_type::iterator() const {return i_;}

		friend class set;
		friend class set::const_iterator;
	};

	friend class const_iterator;
	class const_iterator
		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>
	{
	public:
		const_iterator() {}
		const_iterator(const set::iterator& i) : i_(i) {}
	public:
		const_reference operator * () const {return *i_;}
		const_pointer operator -> () const {return i_.operator->();}
		const_iterator& operator ++ () {++i_; return *this;}
		const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}
		const_iterator& operator -- () {--i_; return *this;}
		const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}
		bool operator ==(const const_iterator& rhs) const {return i_ == rhs.i_;}
		bool operator ==(const set::iterator& rhs) const {return *this == const_iterator(rhs);}
		bool operator !=(const const_iterator& rhs) const {return i_ != rhs.i_;}
		bool operator !=(const set::iterator& rhs) const {return *this != const_iterator(rhs);}
	private:
		tree_type::const_iterator i_;

		const_iterator(const tree_type::const_iterator& i) : i_(i) {}
		operator tree_type::const_iterator() const {return i_;}

		friend class set;
		friend class set::iterator;
	};

	//  lib.set.cons construct/copy/destroy:
	explicit set(const Compare& comp = Compare(), const Allocator& a = Allocator());
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			set(InputIterator first, InputIterator last, const Compare& comp = Compare(),
				const Allocator& a = Allocator())
				: tree_(first, last, false, comp, a)
			{
			}
	#else
		set(const_iterator first, const_iterator last, const Compare& comp = Compare(),
			const Allocator& a = Allocator());
		set(const value_type* first, const value_type* last, const Compare& comp = Compare(),
			const Allocator& a = Allocator());
	#endif
	allocator_type get_allocator() const;

	//  iterators:
	iterator               begin();
	const_iterator         begin() const;
	iterator               end();
	const_iterator         end() const;
	reverse_iterator       rbegin();
	const_reverse_iterator rbegin() const;
	reverse_iterator       rend();
	const_reverse_iterator rend() const;

	//  capacity:
	bool          empty() const;
	size_type     size() const;
	size_type     max_size() const;

	//  modifiers:
	pair<iterator,bool> insert(const value_type& x);
	iterator            insert(iterator position, const value_type& x);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			void insert(InputIterator first, InputIterator last)
			{
				tree_.insert_one(first, last);
			}
	#else
		void insert(const_iterator first, const_iterator last);
		void insert(const value_type* first, const value_type* last);
	#endif

	void      erase(iterator position);
	size_type erase(const key_type& x);
	void      erase(iterator first, iterator last);
	void swap(set<Key,Compare,Allocator>& x);
	void clear();

	//  observers:
	key_compare   key_comp() const;
	value_compare value_comp() const;

	//  set operations:
	iterator  find(const key_type& x) const;
	size_type count(const key_type& x) const;

	iterator  lower_bound(const key_type& x) const;
	iterator  upper_bound(const key_type& x) const;
	pair<iterator,iterator> equal_range(const key_type& x) const;
private:
	tree_type tree_;
};

template <class Key, class Compare, class Allocator>
bool
operator==(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator< (const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator!=(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator> (const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator>=(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator<=(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);

//  specialized algorithms:
template <class Key, class Compare, class Allocator>
void
swap(set<Key,Compare,Allocator>& x, set<Key,Compare,Allocator>& y);

// multiset

template <class Key, class Compare = less<Key>, class Allocator = allocator<Key> >
class multiset
{
public:
	//  types:
	typedef Key                                   key_type;
	typedef Key                                   value_type;
	typedef Compare                               key_compare;
	typedef Compare                               value_compare;
	typedef Allocator                             allocator_type;
	typedef typename Allocator::reference         reference;
	typedef typename Allocator::const_reference   const_reference;
	class                                         iterator;
	class                                         const_iterator;
	typedef typename Allocator::size_type         size_type;
	typedef typename Allocator::difference_type   difference_type;
	typedef typename Allocator::pointer           pointer;
	typedef typename Allocator::const_pointer     const_pointer;
	typedef _STD::reverse_iterator<iterator>       reverse_iterator;
	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;

private:
	typedef __tree<value_type, value_compare, allocator_type> tree_type;
public:

	struct debug_view
	{
		debug_view* left_;
		debug_view* right_;
		debug_view* parent_;
		value_type data_;
	};

	friend class iterator;
	class iterator
		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>
	{
	public:
		iterator() {}
		const_reference operator * () const {return *i_;}
		const_pointer operator -> () const {return i_.operator->();}
		iterator& operator ++ () {++i_; return *this;}
		iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}
		iterator& operator -- () {--i_; return *this;}
		iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}
		bool operator ==(const iterator& rhs) const {return i_ == rhs.i_;}
		bool operator ==(const const_iterator& rhs) const {return const_iterator(*this) == rhs;}
		bool operator !=(const iterator& rhs) const {return i_ != rhs.i_;}
		bool operator !=(const const_iterator& rhs) const {return const_iterator(*this) != rhs;}
	private:
		tree_type::iterator i_;

		iterator(const tree_type::iterator& i) : i_(i) {}
		operator tree_type::iterator() const {return i_;}

		friend class multiset;
		friend class multiset::const_iterator;
	};

	friend class const_iterator;
	class const_iterator
		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>
	{
	public:
		const_iterator() {}
		const_iterator(const multiset::iterator& i) : i_(i) {}
		const_reference operator * () const {return *i_;}
		const_pointer operator -> () const {return i_.operator->();}
		const_iterator& operator ++ () {++i_; return *this;}
		const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}
		const_iterator& operator -- () {--i_; return *this;}
		const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}
		bool operator ==(const const_iterator& rhs) const {return i_ == rhs.i_;}
		bool operator ==(const multiset::iterator& rhs) const {return *this == const_iterator(rhs);}
		bool operator !=(const const_iterator& rhs) const {return i_ != rhs.i_;}
		bool operator !=(const multiset::iterator& rhs) const {return *this != const_iterator(rhs);}
	private:
		tree_type::const_iterator i_;

		const_iterator(const tree_type::const_iterator& i) : i_(i) {}
		operator tree_type::const_iterator() const {return i_;}

		friend class multiset;
	};


	//  construct/copy/destroy:
	explicit multiset(const Compare& comp = Compare(), const Allocator& a = Allocator());
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			multiset(InputIterator first, InputIterator last, const Compare& comp = Compare(),
				const Allocator& a = Allocator())
				: tree_(first, last, true, comp, a)
			{
			}
	#else
		multiset(const_iterator first, const_iterator last, const Compare& comp = Compare(),
			const Allocator& a = Allocator());
		multiset(const value_type* first, const value_type* last, const Compare& comp = Compare(),
			const Allocator& a = Allocator());
	#endif
	allocator_type get_allocator() const;

	//  iterators:
	iterator               begin();
	const_iterator         begin() const;
	iterator               end();
	const_iterator         end() const;
	reverse_iterator       rbegin();
	const_reverse_iterator rbegin() const;
	reverse_iterator       rend();
	const_reverse_iterator rend() const;

	//  capacity:
	bool          empty() const;
	size_type     size() const;
	size_type     max_size() const;

	//  modifiers:
	iterator insert(const value_type& x);
	iterator insert(iterator position, const value_type& x);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			void insert(InputIterator first, InputIterator last)
			{
				tree_.insert_multi(first, last);
			}
	#else
		void insert(const_iterator first, const_iterator last);
		void insert(const value_type* first, const value_type* last);
	#endif

	void      erase(iterator position);
	size_type erase(const key_type& x);
	void      erase(iterator first, iterator last);
	void swap(multiset<Key,Compare,Allocator>& x);
	void clear();

	//  observers:
	key_compare   key_comp() const;
	value_compare value_comp() const;

	//  set operations:
	iterator  find(const key_type& x) const;
	size_type count(const key_type& x) const;

	iterator  lower_bound(const key_type& x) const;
	iterator  upper_bound(const key_type& x) const;
	pair<iterator,iterator> equal_range(const key_type& x) const;
private:
	tree_type tree_;
};

template <class Key, class Compare, class Allocator>
bool
operator==(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator< (const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator!=(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator> (const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator>=(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);

template <class Key, class Compare, class Allocator>
bool
operator<=(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);

//  specialized algorithms:
template <class Key, class Compare, class Allocator>
void
swap(multiset<Key,Compare,Allocator>& x, multiset<Key,Compare,Allocator>& y);

// set implementation

template <class Key, class Compare, class Allocator>
inline
set<Key, Compare, Allocator>::set(const Compare& comp, const Allocator& a)
	: tree_(comp, a)
{
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

	template <class Key, class Compare, class Allocator>
	inline
	set<Key, Compare, Allocator>::set(const_iterator first, const_iterator last,
		const Compare& comp, const Allocator& a)
		: tree_(first, last, false, comp, a)
	{
	}

	template <class Key, class Compare, class Allocator>
	inline
	set<Key, Compare, Allocator>::set(const value_type* first, const value_type* last,
		const Compare& comp, const Allocator& a)
		: tree_(first, last, false, comp, a)
	{
	}

#endif

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::allocator_type
set<Key, Compare, Allocator>::get_allocator() const
{
	return tree_.get_allocator();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::iterator
set<Key, Compare, Allocator>::begin()
{
	return tree_.begin();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::const_iterator
set<Key, Compare, Allocator>::begin() const
{
	return tree_.begin();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::iterator
set<Key, Compare, Allocator>::end()
{
	return tree_.end();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::const_iterator
set<Key, Compare, Allocator>::end() const
{
	return tree_.end();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::reverse_iterator
set<Key, Compare, Allocator>::rbegin()
{
	return reverse_iterator(end());
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::const_reverse_iterator
set<Key, Compare, Allocator>::rbegin() const
{
	return const_reverse_iterator(end());
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::reverse_iterator
set<Key, Compare, Allocator>::rend()
{
	return reverse_iterator(begin());
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::const_reverse_iterator
set<Key, Compare, Allocator>::rend() const
{
	return const_reverse_iterator(begin());
}

template <class Key, class Compare, class Allocator>
inline
bool
set<Key, Compare, Allocator>::empty() const
{
	return tree_.empty();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::size_type
set<Key, Compare, Allocator>::size() const
{
	return tree_.size();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::size_type
set<Key, Compare, Allocator>::max_size() const
{
	return tree_.max_size();
}

template <class Key, class Compare, class Allocator>
inline
pair<set<Key, Compare, Allocator>::iterator, bool>
set<Key, Compare, Allocator>::insert(const value_type& x)
{
	pair<tree_type::iterator, bool> result = tree_.insert_one(x);
	return pair<iterator, bool>(result.first, result.second);
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::iterator
set<Key, Compare, Allocator>::insert(iterator position, const value_type& x)
{
	return tree_.insert_one(position, x);
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

	template <class Key, class Compare, class Allocator>
	inline
	void
	set<Key, Compare, Allocator>::insert(const_iterator first, const_iterator last)
	{
		tree_.insert_one(first, last);
	}

	template <class Key, class Compare, class Allocator>
	inline
	void
	set<Key, Compare, Allocator>::insert(const value_type* first, const value_type* last)
	{
		tree_.insert_one(first, last);
	}

#endif

template <class Key, class Compare, class Allocator>
inline
void
set<Key, Compare, Allocator>::erase(iterator position)
{
	tree_.erase(position);
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::size_type
set<Key, Compare, Allocator>::erase(const key_type& x)
{
	return tree_.erase_one(x);
}

template <class Key, class Compare, class Allocator>
inline
void
set<Key, Compare, Allocator>::erase(iterator first, iterator last)
{
	tree_.erase(first, last);
}

template <class Key, class Compare, class Allocator>
inline
void
set<Key, Compare, Allocator>::swap(set<Key,Compare,Allocator>& x)
{
	tree_.swap(x.tree_);
}

template <class Key, class Compare, class Allocator>
inline
void
set<Key, Compare, Allocator>::clear()
{
	tree_.clear();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::key_compare
set<Key, Compare, Allocator>::key_comp() const
{
	return tree_.value_comp();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::value_compare
set<Key, Compare, Allocator>::value_comp() const
{
	return tree_.value_comp();
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::iterator
set<Key, Compare, Allocator>::find(const key_type& x) const
{
	return const_cast<tree_type&>(tree_).find(x);
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::size_type
set<Key, Compare, Allocator>::count(const key_type& x) const
{
	return tree_.count_one(x);
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::iterator
set<Key, Compare, Allocator>::lower_bound(const key_type& x) const
{
	return const_cast<tree_type&>(tree_).lower_bound(x);
}

template <class Key, class Compare, class Allocator>
inline
typename set<Key, Compare, Allocator>::iterator
set<Key, Compare, Allocator>::upper_bound(const key_type& x) const
{
	return const_cast<tree_type&>(tree_).upper_bound(x);
}

template <class Key, class Compare, class Allocator>
inline
pair<set<Key, Compare, Allocator>::iterator, set<Key, Compare, Allocator>::iterator>
set<Key, Compare, Allocator>::equal_range(const key_type& x) const
{
	pair<tree_type::iterator, tree_type::iterator> result =
		const_cast<tree_type&>(tree_).equal_range(x);
	return pair<iterator, iterator>(result.first, result.second);
}

template <class Key, class Compare, class Allocator>
inline
bool
operator==(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y)
{
	return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class Compare, class Allocator>
inline
bool
operator!=(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y)
{
	return !(x == y);
}

template <class Key, class Compare, class Allocator>
inline
bool
operator< (const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y)
{
	return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template <class Key, class Compare, class Allocator>
inline
bool
operator> (const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y)
{
	return y < x;
}

template <class Key, class Compare, class Allocator>
inline
bool
operator>=(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y)
{
	return !(x < y);
}

template <class Key, class Compare, class Allocator>
inline
bool
operator<=(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y)
{
	return !(y < x);
}

template <class Key, class Compare, class Allocator>
inline
void
swap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y)
{
	x.swap(y);
}

// multiset implementation

template <class Key, class Compare, class Allocator>
inline
multiset<Key, Compare, Allocator>::multiset(const Compare& comp, const Allocator& a)
	: tree_(comp, a)
{
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

	template <class Key, class Compare, class Allocator>
	inline
	multiset<Key, Compare, Allocator>::multiset(const_iterator first, const_iterator last,
		const Compare& comp, const Allocator& a)
		: tree_(first, last, true, comp, a)
	{
	}

	template <class Key, class Compare, class Allocator>
	inline
	multiset<Key, Compare, Allocator>::multiset(const value_type* first, const value_type* last,
		const Compare& comp, const Allocator& a)
		: tree_(first, last, true, comp, a)
	{
	}

#endif

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::allocator_type
multiset<Key, Compare, Allocator>::get_allocator() const
{
	return tree_.get_allocator();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::iterator
multiset<Key, Compare, Allocator>::begin()
{
	return tree_.begin();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::const_iterator
multiset<Key, Compare, Allocator>::begin() const
{
	return tree_.begin();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::iterator
multiset<Key, Compare, Allocator>::end()
{
	return tree_.end();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::const_iterator
multiset<Key, Compare, Allocator>::end() const
{
	return tree_.end();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::reverse_iterator
multiset<Key, Compare, Allocator>::rbegin()
{
	return reverse_iterator(end());
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::const_reverse_iterator
multiset<Key, Compare, Allocator>::rbegin() const
{
	return const_reverse_iterator(end());
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::reverse_iterator
multiset<Key, Compare, Allocator>::rend()
{
	return reverse_iterator(begin());
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::const_reverse_iterator
multiset<Key, Compare, Allocator>::rend() const
{
	return const_reverse_iterator(begin());
}

template <class Key, class Compare, class Allocator>
inline
bool
multiset<Key, Compare, Allocator>::empty() const
{
	return tree_.empty();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::size_type
multiset<Key, Compare, Allocator>::size() const
{
	return tree_.size();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::size_type
multiset<Key, Compare, Allocator>::max_size() const
{
	return tree_.max_size();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::iterator
multiset<Key, Compare, Allocator>::insert(const value_type& x)
{
	return tree_.insert_multi(x);
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::iterator
multiset<Key, Compare, Allocator>::insert(iterator position, const value_type& x)
{
	return tree_.insert_multi(position, x);
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

	template <class Key, class Compare, class Allocator>
	inline
	void
	multiset<Key, Compare, Allocator>::insert(const_iterator first, const_iterator last)
	{
		tree_.insert_multi(first, last);
	}

	template <class Key, class Compare, class Allocator>
	inline
	void
	multiset<Key, Compare, Allocator>::insert(const value_type* first, const value_type* last)
	{
		tree_.insert_multi(first, last);
	}

#endif

template <class Key, class Compare, class Allocator>
inline
void
multiset<Key, Compare, Allocator>::erase(iterator position)
{
	tree_.erase(position);
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::size_type
multiset<Key, Compare, Allocator>::erase(const key_type& x)
{
	return tree_.erase_multi(x);
}

template <class Key, class Compare, class Allocator>
inline
void
multiset<Key, Compare, Allocator>::erase(iterator first, iterator last)
{
	tree_.erase(first, last);
}

template <class Key, class Compare, class Allocator>
inline
void
multiset<Key, Compare, Allocator>::swap(multiset<Key,Compare,Allocator>& x)
{
	tree_.swap(x.tree_);
}

template <class Key, class Compare, class Allocator>
inline
void
multiset<Key, Compare, Allocator>::clear()
{
	tree_.clear();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::key_compare
multiset<Key, Compare, Allocator>::key_comp() const
{
	return tree_.value_comp();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::value_compare
multiset<Key, Compare, Allocator>::value_comp() const
{
	return tree_.value_comp();
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::iterator
multiset<Key, Compare, Allocator>::find(const key_type& x) const
{
	return const_cast<tree_type&>(tree_).find(x);
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::size_type
multiset<Key, Compare, Allocator>::count(const key_type& x) const
{
	return tree_.count_multi(x);
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::iterator
multiset<Key, Compare, Allocator>::lower_bound(const key_type& x) const
{
	return const_cast<tree_type&>(tree_).lower_bound(x);
}

template <class Key, class Compare, class Allocator>
inline
typename multiset<Key, Compare, Allocator>::iterator
multiset<Key, Compare, Allocator>::upper_bound(const key_type& x) const
{
	return const_cast<tree_type&>(tree_).upper_bound(x);
}

template <class Key, class Compare, class Allocator>
inline
pair<multiset<Key, Compare, Allocator>::iterator, multiset<Key, Compare, Allocator>::iterator>
multiset<Key, Compare, Allocator>::equal_range(const key_type& x) const
{
	pair<tree_type::iterator, tree_type::iterator> result =
		const_cast<tree_type&>(tree_).equal_range(x);
	return pair<iterator, iterator>(result.first, result.second);
}

template <class Key, class Compare, class Allocator>
inline
bool
operator==(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y)
{
	return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class Key, class Compare, class Allocator>
inline
bool
operator!=(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y)
{
	return !(x == y);
}

template <class Key, class Compare, class Allocator>
inline
bool
operator< (const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y)
{
	return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template <class Key, class Compare, class Allocator>
inline
bool
operator> (const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y)
{
	return y < x;
}

template <class Key, class Compare, class Allocator>
inline
bool
operator>=(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y)
{
	return !(x < y);
}

template <class Key, class Compare, class Allocator>
inline
bool
operator<=(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y)
{
	return !(y < x);
}

template <class Key, class Compare, class Allocator>
inline
void
swap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y)
{
	x.swap(y);
}

#ifndef _MSL_NO_CPP_NAMESPACE
	} // namespace std
#endif

#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
	#pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _SET

// hh 971220 fixed MOD_INCLUDE
// hh 971223 Changed filename from set.h to set
// hh 971223 Made include guards standard
// hh 971223 added alignment wrapper
// hh 971230 added RC_INVOKED wrapper
// DWA 980305 changed iterator to const_iterator in multiset constructor, hh 980311 checked
// hh 981130 Rewrote
