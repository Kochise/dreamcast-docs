/*  Metrowerks Standard Library  */

/*  $Date: 1999/03/15 19:16:30 $ 
 *  $Revision: 1.10 $ 
 *  $NoKeywords: $ 
 *
 *		Portions Copyright © 1995-1999 Metrowerks, Inc.
 *		All rights reserved.
 */

/**
 ** deque
 **/

#ifndef _DEQUE
#define _DEQUE

#include <mslconfig>

#include <iterator>
#include <new>
#include <memory>
#include <algorithm>
#include <limits>
#include <cdeque>

#ifndef RC_INVOKED

#pragma options align=native
#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
	#pragma import on
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
	namespace std {
#endif

template <class T, class Allocator = allocator<T> >
class deque
{
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <bool b> struct chooser {};
	#endif
public:
	// types:
	typedef typename Allocator::reference         reference;
	typedef typename Allocator::const_reference   const_reference;
	class                                         iterator;
	class                                         const_iterator;
	typedef typename Allocator::size_type         size_type;
	typedef typename Allocator::difference_type   difference_type;
	typedef T                                     value_type;
	typedef Allocator                             allocator_type;
	typedef typename Allocator::pointer           pointer;
	typedef typename Allocator::const_pointer     const_pointer;
	typedef _STD::reverse_iterator<iterator>       reverse_iterator;
	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;
private:
	typedef _MSL_REBIND (pointer) buf_allocator;
	typedef __cdeque<pointer, buf_allocator> buf_type;
public:
	friend class iterator;
	class iterator
		: public _STD::iterator<random_access_iterator_tag, T, difference_type, pointer, reference>
	{
	public:
		iterator() {}
		reference operator * () const {return *cur_;}
		pointer operator -> () const {return cur_;}
		iterator& operator ++ ()
		{
			++pos_;
			if (++cur_ == end_)
			{
				difference_type buf_size = end_ - *beg_;
				++beg_;
				pointer beg = *beg_;
				cur_ = beg;
				end_ = beg + buf_size;
			}
			return *this;
		}
		iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}
		iterator& operator -- ()
		{
			--pos_;
			pointer beg = *beg_;
			if (cur_ != beg)
				--cur_;
			else
			{
				difference_type buf_size = end_ - beg;
				--beg_;
				end_ = *beg_ + buf_size;
				cur_ = end_ - 1;
			}
			return *this;
		}
		iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}
		iterator& operator += (difference_type n)
		{
			if (n < 0)
				return (*this) -= -n;
			pos_ += n;
			difference_type room = end_ - cur_ ;
			if (n < room)
				cur_ += n;
			else
			{
				difference_type buf_size = end_ - *beg_;
				n -= room;
				beg_ += n / buf_size + 1;
				pointer beg = *beg_;
				cur_ = beg + n % buf_size;
				end_ = beg + buf_size;
			}
			return *this;
		}
		iterator operator + (difference_type n) const {return iterator(*this) += n;}
		iterator& operator -= (difference_type n)
		{
			if (n < 0)
				return (*this) += -n;
			pos_ -= n;
			pointer beg = *beg_;
			difference_type room = cur_ - beg + 1;
			if (n < room)
				cur_ -= n;
			else
			{
				difference_type buf_size = end_ - beg;
				n -= room;
				beg_ -= n / buf_size + 1;
				end_ = *beg_ + buf_size;
				cur_ = end_ - 1 - n % buf_size;
			}
			return *this;
		}
		iterator operator - (difference_type n) const {return iterator(*this) -= n;}
		difference_type operator - (const iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}
		reference operator [] (size_type i) const {iterator tmp(*this); tmp += difference_type(i); return *tmp;}
		bool operator ==(const iterator& rhs) const {return cur_ == rhs.cur_;}
		bool operator !=(const iterator& rhs) const {return cur_ != rhs.cur_;}
		bool operator < (const iterator& rhs) const {return pos_ <  rhs.pos_;}
		bool operator <=(const iterator& rhs) const {return pos_ <= rhs.pos_;}
		bool operator > (const iterator& rhs) const {return pos_ >  rhs.pos_;}
		bool operator >=(const iterator& rhs) const {return pos_ >= rhs.pos_;}
		friend iterator operator + (difference_type n, const iterator& rhs)
			{return iterator(rhs) += n;}
	private:
		buf_type::iterator beg_;
		pointer cur_;
		pointer end_;
		size_type pos_;

		iterator(const buf_type::iterator& beg, pointer cur, pointer end, size_type pos)
			: beg_(beg),
			  cur_(cur),
			  end_(end),
			  pos_(pos)
		{}

		friend class deque;
		friend class deque::const_iterator;
	};

	friend class const_iterator;
	class const_iterator
		: public _STD::iterator<random_access_iterator_tag, T, difference_type, const_pointer, const_reference>
	{
	public:
		const_iterator() {}
		const_iterator(const deque::iterator& rhs) : beg_(rhs.beg_), cur_(rhs.cur_), end_(rhs.end_), pos_(rhs.pos_) {}
		const_reference operator * () const {return *cur_;}
		const_pointer operator -> () const {return cur_;}
		const_iterator& operator ++ ()
		{
			++pos_;
			if (++cur_ == end_)
			{
				difference_type buf_size = end_ - *beg_;
				++beg_;
				pointer beg = *beg_;
				cur_ = beg;
				end_ = beg + buf_size;
			}
			return *this;
		}
		const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}
		const_iterator& operator -- ()
		{
			--pos_;
			pointer beg = *beg_;
			if (cur_ != beg)
				--cur_;
			else
			{
				difference_type buf_size = end_ - beg;
				--beg_;
				end_ = *beg_ + buf_size;
				cur_ = end_ - 1;
			}
			return *this;
		}
		const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}
		const_iterator& operator += (difference_type n)
		{
			if (n < 0)
				return (*this) -= -n;
			pos_ += n;
			difference_type room = end_ - cur_ ;
			if (n < room)
				cur_ += n;
			else
			{
				difference_type buf_size = end_ - *beg_;
				n -= room;
				beg_ += n / buf_size + 1;
				pointer beg = *beg_;
				cur_ = beg + n % buf_size;
				end_ = beg + buf_size;
			}
			return *this;
		}
		const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}
		const_iterator& operator -= (difference_type n)
		{
			if (n < 0)
				return (*this) += -n;
			pos_ -= n;
			pointer beg = *beg_;
			difference_type room = cur_ - beg + 1;
			if (n < room)
				cur_ -= n;
			else
			{
				difference_type buf_size = end_ - beg;
				n -= room;
				beg_ -= n / buf_size + 1;
				end_ = *beg_ + buf_size;
				cur_ = end_ - 1 - n % buf_size;
			}
			return *this;
		}
		const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}
		difference_type operator - (const const_iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}
		const_reference operator [] (size_type i) const {const_iterator tmp(*this); tmp += difference_type(i); return *tmp;}
		bool operator ==(const const_iterator& rhs) const {return cur_ == rhs.cur_;}
		bool operator !=(const const_iterator& rhs) const {return cur_ != rhs.cur_;}
		bool operator < (const const_iterator& rhs) const {return pos_ <  rhs.pos_;}
		bool operator <=(const const_iterator& rhs) const {return pos_ <= rhs.pos_;}
		bool operator > (const const_iterator& rhs) const {return pos_ >  rhs.pos_;}
		bool operator >=(const const_iterator& rhs) const {return pos_ >= rhs.pos_;}
		friend const_iterator operator + (difference_type n, const const_iterator& rhs)
			{return const_iterator(rhs) += n;}
	private:
		buf_type::const_iterator beg_;
		const_pointer cur_;
		const_pointer end_;
		size_type pos_;

		const_iterator(const buf_type::const_iterator& beg, const_pointer cur, const_pointer end, size_type pos)
			: beg_(beg),
			  cur_(cur),
			  end_(end),
			  pos_(pos)
		{}

		friend class deque;
	};

	// _lib.deque.cons_ construct/copy/destroy:
	explicit deque(const Allocator& = Allocator());
	explicit deque(size_type n, const T& value = T(), const Allocator& = Allocator());
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			deque(InputIterator first, InputIterator last, const Allocator& a = Allocator())
				: alloc_(a, default_bufsize_s),
				  buf_(buf_allocator(a)),
				  start_(0),
				  size_(0)
			{
				choose_init(first, last, chooser<numeric_limits<InputIterator>::is_integer>());
			}
	#else
		deque(const_iterator first, const_iterator last, const Allocator& = Allocator());
		deque(const value_type* first, const value_type* last, const Allocator& = Allocator());
	#endif
	deque(const deque<T,Allocator>& x);
	~deque();
	deque<T,Allocator>& operator=(const deque<T,Allocator>& x);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			void assign(InputIterator first, InputIterator last)
			{
				choose_assign(first, last, chooser<numeric_limits<InputIterator>::is_integer>());
			}
	#else
		void assign(const_iterator first, const_iterator last);
		void assign(const value_type* first, const value_type* last);
	#endif
	void assign(size_type n, const T& t);
	allocator_type get_allocator() const;
	// iterators:
	iterator               begin();
	const_iterator         begin() const;
	iterator               end();
	const_iterator         end() const;
	reverse_iterator       rbegin();
	const_reverse_iterator rbegin() const;
	reverse_iterator       rend();
	const_reverse_iterator rend() const;
	// _lib.deque.capacity_ capacity:
	size_type size() const;
	size_type max_size() const;
	void      resize(size_type sz, T c = T());
	bool      empty() const;

	// element access:
	reference       operator[](size_type n);
	const_reference operator[](size_type n) const;
	reference       at(size_type n);
	const_reference at(size_type n) const;
	reference       front();
	const_reference front() const;
	reference       back();
	const_reference back() const;
	// _lib.deque.modifiers_ modifiers:
	void push_front(const T& x);
	void push_back(const T& x);
	iterator insert(iterator position, const T& x);
	void     insert(iterator position, size_type n, const T& x);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			void insert(iterator position, InputIterator first, InputIterator last)
			{
				choose_insert(position, first, last, chooser<numeric_limits<InputIterator>::is_integer>());
			}
	#else
		void insert(iterator position, const_iterator first, const_iterator last);
		void insert(iterator position, const value_type* first, const value_type* last);
	#endif
	void pop_front();
	void pop_back();
	iterator erase(iterator position);
	iterator erase(iterator first, iterator last);
	void     swap(deque<T,Allocator>&);
	void     clear();
private:
	static const size_type min_buf_size_s = 8;
	static const size_type min_foot_print_s = 512;
	static const size_type default_bufsize_s = sizeof(T) * min_buf_size_s < min_foot_print_s ?
	                                           min_foot_print_s / sizeof(T) : min_buf_size_s;
	_EmptyMemberOpt<Allocator, size_type> alloc_;  // alloc_.m_ is bufsize_
	buf_type buf_;
	size_type start_;
	size_type size_;

	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <class InputIterator>
			inline
			void
			choose_init(InputIterator first, InputIterator last, chooser<true>)
			{
				init(static_cast<size_type>(first), static_cast<value_type>(last));
			}

		template <class InputIterator>
			inline
			void
			choose_init(InputIterator first, InputIterator last, chooser<false>)
			{
				init(first, last, iterator_traits<InputIterator>::iterator_category());
			}

		template <class InputIterator>
			void
			init(InputIterator first, InputIterator last, input_iterator_tag)
			{
				#ifndef _MSL_NO_EXCEPTIONS
				try
				{
				#endif
					for (; first != last; ++first)
						push_back(*first);
				#ifndef _MSL_NO_EXCEPTIONS
				}
				catch (...)
				{
					tear_down();
					throw;
				}
				#endif
			}

		template <class ForwardIterator>
			void
			init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
			{
				size_ = (size_type)distance(first, last);
				if (size_ > max_size())
					#ifndef _MSL_NO_EXCEPTIONS
						throw length_error("deque::construction length error");
					#else
					{
						fprintf(stderr, "deque::construction length error\n");
						abort();
					}
					#endif
				if (size_ > 0)
				{
					init_buf();
					if (alloc_.m_ < size_)
						alloc_.m_ = size_;
					pointer tmp = alloc_.allocate(alloc_.m_);
					#ifndef _MSL_NO_EXCEPTIONS
					try
					{
					#endif
						buf_.front() = tmp;
						buf_.push_back(0);
						start_ = (alloc_.m_ - size_) / 2;
						uninitialized_copy(first, last, tmp + start_);
					#ifndef _MSL_NO_EXCEPTIONS
					}
					catch (...)
					{
						alloc_.deallocate(tmp, alloc_.m_);
						throw;
					}
					#endif
				}
			}

		template <class InputIterator>
			inline
			void
			choose_assign(InputIterator first, InputIterator last, chooser<true>)
			{
				assign(static_cast<size_type>(first), static_cast<value_type>(last));
			}

		template <class InputIterator>
			inline
			void
			choose_assign(InputIterator first, InputIterator last, chooser<false>)
			{
				do_assign(first, last, iterator_traits<InputIterator>::iterator_category());
			}

		template <class InputIterator>
			void
			do_assign(InputIterator first, InputIterator last, input_iterator_tag)
			{
				deque temp(first, last, get_allocator());
				const deque& tempr = temp;
				do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
			}

		template <class ForwardIterator>
			void
			do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
			{
				size_type n = (size_type)distance(first, last);
				if (n > max_size())
					#ifndef _MSL_NO_EXCEPTIONS
						throw length_error("deque::assign length error");
					#else
					{
						fprintf(stderr, "deque::assign length error\n");
						abort();
					}
					#endif
				if (buf_.empty())
					init_buf();
				while (n > capacity())
				{
					pointer tmp = alloc_.allocate(alloc_.m_);
					#ifndef _MSL_NO_EXCEPTIONS
					try
					{
					#endif
						buf_.back() = tmp;
						buf_.push_back(0);
					#ifndef _MSL_NO_EXCEPTIONS
					}
					catch (...)
					{
						alloc_.deallocate(tmp, alloc_.m_);
						buf_.back() = 0;
						throw;
					}
					#endif
				}
				destroy(begin(), end());
				size_ = 0;
				start_ = (capacity() - n) / 2;
				while (start_ >= alloc_.m_)
				{
					buf_.pop_back();
					pointer& p = buf_.back();
					alloc_.deallocate(p, alloc_.m_);
					p = 0;
					start_ = (capacity() - n) / 2;
				}
				uninitialized_copy(first, last, begin());
				size_ = n;
			}

		template <class InputIterator>
			inline
			void
			choose_insert(iterator position, InputIterator first, InputIterator last,
				chooser<true>)
			{
				insert(position, static_cast<size_type>(first), static_cast<value_type>(last));
			}

		template <class InputIterator>
			inline
			void
			choose_insert(iterator position, InputIterator first, InputIterator last,
				chooser<false>)
			{
				do_insert(position, first, last, iterator_traits<InputIterator>::iterator_category());
			}

		template <class InputIterator>
			void
			do_insert(iterator position, InputIterator first, InputIterator last,
				input_iterator_tag)
			{
				deque temp(first, last, get_allocator());
				const deque& tempr = temp;
				do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());
			}

		template <class ForwardIterator>
			void
			do_insert(iterator position, ForwardIterator first, ForwardIterator last,
				forward_iterator_tag)
			{
				size_type n = (size_type)distance(first, last);
				if (n == 0)
					return;
				size_type ms = max_size();
				if (n > ms || size_ > ms - n)
					#ifndef _MSL_NO_EXCEPTIONS
						throw length_error("deque::insert length error");
					#else
					{
						fprintf(stderr, "deque::insert length error\n");
						abort();
					}
					#endif
				if (buf_.empty())
					init_buf();
				size_type pb = position.pos_ - start_;
				size_type pe = size_ - pb;
				if (pb <= pe)  // hh 981210
				{
					size_type new_buffers = 0;
					size_type oldstart = start_;
					buf_type orig_buf;
					bool buf_invalidated = false;
					if (start_ < n)
						buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
					else
						start_ -= n;
					size_type done = 0;
					iterator beg = begin();
					#ifndef _MSL_NO_EXCEPTIONS
					try
					{
					#endif
						if (pb == 0) // insert at begin()
							uninitialized_copy(first, last, beg);
						else // pos in [1, size_ / 2)
						{
							iterator b_n = beg + difference_type(n);
							iterator b_n_pb = b_n + difference_type(pb);
							iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
							iterator t;
							if (pb > n)
								t = beg + difference_type(2*n);
							else
								t = b_n_pb;
							uninitialized_copy(b_n, t, beg);
							ForwardIterator i = first;
							if (pb > n)
							{
								done = n;
								copy(t, b_n_pb, b_n);
								t = b_pb;
							}
							else if (pb < n)
							{
								done = pb;
								advance(i, difference_type(n - pb));
								uninitialized_copy(first, i, b_pb);
								done = n;
								t = b_n;
							}
							else
							{
								done = n;
								t = b_n;
							}
							copy(i, last, t);
						}
						size_ += n;
					#ifndef _MSL_NO_EXCEPTIONS
					}
					catch (...)
					{
						destroy(beg, beg + difference_type(done));
						for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
						{
							alloc_.deallocate(buf_.front(), alloc_.m_);
							buf_.pop_front();
						}
						if (buf_invalidated)
							buf_.swap(orig_buf);
						start_ = oldstart;
						throw;
					}
					#endif
				}
				else // pos >= size_ / 2
				{
					size_type new_buffers = 0;
					buf_type orig_buf;
					bool buf_invalidated = false;
					size_type e = capacity() - (start_ + size_);
					bool done = false;
					if (e < n)
						buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
					iterator t2;
					#ifndef _MSL_NO_EXCEPTIONS
					try
					{
					#endif
						if (pe == 0) // insert at end()
							uninitialized_copy(first, last, end());
						else // pos in [size_ / 2, size_)
						{
							iterator ei = end();
							iterator e_n = ei - difference_type(n);
							iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
							iterator t1;
							if (pe >= n)
							{
								t1 = e_n;
								t2 = ei;
							}
							else
							{
								t1 = e_pe;
								t2 = ei + difference_type(n - pe);
							}
							uninitialized_copy(t1, ei, t2);
							done = true;
							if (pe >= n)
							{
								if (pe > n)
									copy_backward(e_pe, e_n, ei);
								copy(first, last, e_pe);
							}
							else if (n > pe)
							{
								ForwardIterator i = first;
								advance(i, difference_type(pe));
								copy(first, i, e_pe);
								uninitialized_copy(i, last, ei);
							}
						}
						size_ += n;
					#ifndef _MSL_NO_EXCEPTIONS
					}
					catch (...)
					{
						if (done)
							destroy(t2, end() + difference_type(n));
						for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
						{
							buf_.pop_back();
							pointer& p = buf_.back();
							alloc_.deallocate(p, alloc_.m_);
							p = 0;
						}
						if (buf_invalidated)
							buf_.swap(orig_buf);
						throw;
					}
					#endif
				}
				invalidate_iterators();
			}

	#endif
	void init(size_type n, const T& value);
	void tear_down();
	void destroy(iterator first, iterator last);
	void invalidate_iterators();
	iterator make_iterator(size_type pos);
	const_iterator make_iterator(size_type pos) const;
	void init_buf();
	size_type capacity() const;
	bool grow_buf_front(size_type oldstart, buf_type& orig_buf, size_type& new_buffers, size_type n);
	bool grow_buf_back(size_type e, buf_type& orig_buf, size_type& new_buffers, size_type n);
};

template <class T, class Allocator>
bool
operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>
bool
operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>
bool
operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>
bool
operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>
bool
operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

template <class T, class Allocator>
bool
operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);

// specialized algorithms:

template <class T, class Allocator>
void
swap(deque<T,Allocator>& x, deque<T,Allocator>& y);

// Implementation deque

template <class T, class Allocator>
inline
void
deque<T, Allocator>::invalidate_iterators()
{
	while (start_ >= 3 * alloc_.m_ / 2)
	{
		alloc_.deallocate(buf_.front(), alloc_.m_);
		buf_.pop_front();
		start_ -= alloc_.m_;
	}
}

template <class T, class Allocator>
typename deque<T, Allocator>::iterator
deque<T, Allocator>::make_iterator(size_type pos)
{
	buf_type::iterator b = buf_.begin();
	pointer cur;
	pointer beg;
	if (pos < alloc_.m_)
	{
		if (!buf_.empty())
			beg = *b;
		else
			beg = 0;
		cur = beg + pos;
	}
	else
	{
		b += difference_type(pos / alloc_.m_);
		beg = *b;
		cur = beg + pos % alloc_.m_;
	}
	return iterator(b, cur, beg + alloc_.m_, pos);
}

template <class T, class Allocator>
typename deque<T, Allocator>::const_iterator
deque<T, Allocator>::make_iterator(size_type pos) const
{
	buf_type::const_iterator b = buf_.begin();
	const_pointer cur;
	const_pointer beg;
	if (pos < alloc_.m_)
	{
		if (!buf_.empty())
			beg = *b;
		else
			beg = 0;
		cur = beg + pos;
	}
	else
	{
		b += difference_type(pos / alloc_.m_);
		beg = *b;
		cur = beg + pos % alloc_.m_;
	}
	return const_iterator(b, cur, beg + alloc_.m_, pos);
}

template <class T, class Allocator>
inline
void
deque<T, Allocator>::init_buf()
{
	buf_.reserve(2);
	buf_.resize(1);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::size_type
deque<T, Allocator>::capacity() const
{
	return (buf_.size() - 1) * alloc_.m_;
}

template <class T, class Allocator>
bool
deque<T, Allocator>::grow_buf_front(size_type oldstart, buf_type& orig_buf, size_type& new_buffers, size_type n)
{
	bool buf_invalidated = false;
	size_type nc = n;
	nc -= start_;
	while (true)
	{
		pointer tmp = alloc_.allocate(alloc_.m_);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			if (!buf_invalidated && buf_.size() == buf_.capacity())
			{
				buf_.swap(orig_buf);
				buf_invalidated = true;
				buf_.reserve(2*orig_buf.capacity());
				buf_.assign(orig_buf.begin(), orig_buf.end());
			}
			buf_.push_front(tmp);
			++new_buffers;  // hh 981210
			start_ += alloc_.m_;
			if (nc <= alloc_.m_)
			{
				if (size_ != 0)  // hh 981210
					start_ -= n;
				else
					start_ = (capacity() - n) / 2;
				break;
			}
			nc -= alloc_.m_;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(tmp, alloc_.m_);
			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
			{
				alloc_.deallocate(buf_.front(), alloc_.m_);
				buf_.pop_front();
			}
			if (buf_invalidated)
				buf_.swap(orig_buf);
			start_ = oldstart;
			throw;
		}
		#endif
	}
	return buf_invalidated;
}

template <class T, class Allocator>
bool
deque<T, Allocator>::grow_buf_back(size_type e, buf_type& orig_buf, size_type& new_buffers, size_type n)
{
	bool buf_invalidated = false;
	size_type nc = n;
	nc -= e;
	while (true)
	{
		pointer tmp = alloc_.allocate(alloc_.m_);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			if (!buf_invalidated && buf_.size() == buf_.capacity())
			{
				buf_.swap(orig_buf);
				buf_invalidated = true;
				buf_.reserve(2*orig_buf.capacity());
				buf_.assign(orig_buf.begin(), orig_buf.end());
			}
			buf_.back() = tmp;
			buf_.push_back(0);
			++new_buffers;
			if (nc <= alloc_.m_)
				break;
			nc -= alloc_.m_;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(tmp, alloc_.m_);
			if (!buf_.empty())		// 990315 hh
				buf_.back() = 0;
			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
			if (buf_invalidated)
				buf_.swap(orig_buf);
			throw;
		}
		#endif
	}
	return buf_invalidated;
}

template <class T, class Allocator>
deque<T, Allocator>::deque(const Allocator& a)
	: alloc_(a, default_bufsize_s),
#ifndef _MSL_NO_MEMBER_TEMPLATE
	  buf_(buf_allocator(a)),
#endif
	  start_(0),
	  size_(0)
{
}

template <class T, class Allocator>
deque<T, Allocator>::deque(size_type n, const T& value, const Allocator& a)
	: alloc_(a, default_bufsize_s),
#ifndef _MSL_NO_MEMBER_TEMPLATE
	  buf_(buf_allocator(a)),
#endif
	  start_(0),
	  size_(0)
{
	init(n, value);
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

	template <class T, class Allocator>
	deque<T, Allocator>::deque(const_iterator first, const_iterator last, const Allocator& a)
		: alloc_(a, default_bufsize_s),
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		  buf_(buf_allocator(a)),
	#endif
		  start_(0),
		  size_(size_type(last - first))
	{
		if (size_ > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::construction length error");
			#else
			{
				fprintf(stderr, "deque::construction length error\n");
				abort();
			}
			#endif
		if (size_ > 0)
		{
			init_buf();
			if (alloc_.m_ < size_)
				alloc_.m_ = size_;
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				buf_.front() = tmp;
				buf_.push_back(0);
				start_ = (alloc_.m_ - size_) / 2;
				uninitialized_copy(first, last, tmp + start_);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				throw;
			}
			#endif
		}
	}

	template <class T, class Allocator>
	deque<T, Allocator>::deque(const value_type* first, const value_type* last, const Allocator& a)
		: alloc_(a, default_bufsize_s),
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		  buf_(buf_allocator(a)),
	#endif
		  start_(0),
		  size_(size_type(last - first))
	{
		if (size_ > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::construction length error");
			#else
			{
				fprintf(stderr, "deque::construction length error\n");
				abort();
			}
			#endif
		if (size_ > 0)
		{
			init_buf();
			if (alloc_.m_ < size_)
				alloc_.m_ = size_;
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				buf_.front() = tmp;
				buf_.push_back(0);
				start_ = (alloc_.m_ - size_) / 2;
				uninitialized_copy(first, last, tmp + start_);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				throw;
			}
			#endif
		}
	}

#endif

template <class T, class Allocator>
void
deque<T, Allocator>::init(size_type n, const T& value)
{
	if (n > max_size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("deque::construction length error");
		#else
		{
			fprintf(stderr, "deque::construction length error\n");
			abort();
		}
		#endif
	if (n > 0)
	{
		init_buf();
		if (alloc_.m_ < n)
			alloc_.m_ = n;
		pointer tmp = alloc_.allocate(alloc_.m_);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			buf_.front() = tmp;
			buf_.push_back(0);
			size_ = n;
			start_ = (alloc_.m_ - size_) / 2;
			uninitialized_fill_n(tmp + start_, size_, value);
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(tmp, alloc_.m_);
			throw;
		}
		#endif
	}
}

template <class T, class Allocator>
deque<T, Allocator>::deque(const deque<T,Allocator>& x)
	: alloc_(x.alloc_, default_bufsize_s),
#ifndef _MSL_NO_MEMBER_TEMPLATE
	  buf_(buf_allocator(alloc_)),
#endif
	  start_(0),
	  size_(x.size_)
{
	if (size_ > 0)
	{
		init_buf();
		if (alloc_.m_ < size_)
			alloc_.m_ = size_;
		pointer tmp = alloc_.allocate(alloc_.m_);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			buf_.front() = tmp;
			buf_.push_back(0);
			start_ = (alloc_.m_ - size_) / 2;
			uninitialized_copy(x.begin(), x.end(), tmp + start_);
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(tmp, alloc_.m_);
			throw;
		}
		#endif
	}
}

template <class T, class Allocator>
inline
deque<T, Allocator>::~deque()
{
	tear_down();
}

template <class T, class Allocator>
void
deque<T, Allocator>::tear_down()
{
	if (!buf_.empty())
	{
		destroy(begin(), end());
		buf_type::iterator e = --buf_.end();
		for (buf_type::iterator i = buf_.begin(); i != e; ++i)
			alloc_.deallocate(*i, alloc_.m_);
	}
}

template <class T, class Allocator>
void
deque<T, Allocator>::destroy(iterator first, iterator last)
{
	if (first != last)
	{
		size_type diff = size_type(last - first);
		size_type i = first.pos_;
		size_type w = i / alloc_.m_;
		i %= alloc_.m_;
		size_type e = min(alloc_.m_, i + diff);
		buf_type::iterator bi = buf_.begin() + difference_type(w);
		pointer p = *bi;
		_STD::destroy(p + i, p + e);
		diff -= e - i;
		if (diff == 0)
			return;
		++bi;
		while (diff >= alloc_.m_)
		{
			p = *bi;
			_STD::destroy(p, p + alloc_.m_);
			++bi;
			diff -= alloc_.m_;
		}
		if (diff > 0)
		{
			p = *bi;
			_STD::destroy(p, p + diff);
		}
	}
}

template <class T, class Allocator>
inline
deque<T,Allocator>&
deque<T, Allocator>::operator=(const deque<T,Allocator>& x)
{
	if (this != &x)
		assign(x.begin(), x.end());
	return *this;
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

	template <class T, class Allocator>
	void
	deque<T, Allocator>::assign(const_iterator first, const_iterator last)
	{
		size_type n = (size_type)distance(first, last);
		if (n > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::assign length error");
			#else
			{
				fprintf(stderr, "deque::assign length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		while (n > capacity())
		{
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				buf_.back() = tmp;
				buf_.push_back(0);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				buf_.back() = 0;
				throw;
			}
			#endif
		}
		destroy(begin(), end());
		size_ = 0;
		start_ = (capacity() - n) / 2;
		while (start_ >= alloc_.m_)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
			start_ = (capacity() - n) / 2;
		}
		uninitialized_copy(first, last, begin());
		size_ = n;
	}

	template <class T, class Allocator>
	void
	deque<T, Allocator>::assign(const value_type* first, const value_type* last)
	{
		size_type n = (size_type)distance(first, last);
		if (n > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::assign length error");
			#else
			{
				fprintf(stderr, "deque::assign length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		while (n > capacity())
		{
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				buf_.back() = tmp;
				buf_.push_back(0);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				buf_.back() = 0;
				throw;
			}
			#endif
		}
		destroy(begin(), end());
		size_ = 0;
		start_ = (capacity() - n) / 2;
		while (start_ >= alloc_.m_)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
			start_ = (capacity() - n) / 2;
		}
		uninitialized_copy(first, last, begin());
		size_ = n;
	}

#endif

template <class T, class Allocator>
void
deque<T, Allocator>::assign(size_type n, const T& t)
{
	if (n > max_size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("deque::assign length error");
		#else
		{
			fprintf(stderr, "deque::assign length error\n");
			abort();
		}
		#endif
	if (buf_.empty())
		init_buf();
	while (n > capacity())
	{
		pointer tmp = alloc_.allocate(alloc_.m_);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			buf_.back() = tmp;
			buf_.push_back(0);
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(tmp, alloc_.m_);
			buf_.back() = 0;
			throw;
		}
		#endif
	}
	destroy(begin(), end());
	size_ = 0;
	start_ = (capacity() - n) / 2;
	while (start_ >= alloc_.m_)
	{
		buf_.pop_back();
		pointer& p = buf_.back();
		alloc_.deallocate(p, alloc_.m_);
		p = 0;
		start_ = (capacity() - n) / 2;
	}
	uninitialized_fill_n(begin(), n, t);
	size_ = n;
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::allocator_type
deque<T, Allocator>::get_allocator() const
{
	return alloc_;
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::iterator
deque<T, Allocator>::begin()
{
	return make_iterator(start_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::const_iterator
deque<T, Allocator>::begin() const
{
	return make_iterator(start_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::iterator
deque<T, Allocator>::end()
{	
	return make_iterator(start_ + size_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::const_iterator
deque<T, Allocator>::end() const
{	
	return make_iterator(start_ + size_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::reverse_iterator
deque<T, Allocator>::rbegin()
{
	return reverse_iterator(end());
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::const_reverse_iterator
deque<T, Allocator>::rbegin() const
{
	return const_reverse_iterator(end());
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::reverse_iterator
deque<T, Allocator>::rend()
{
	return reverse_iterator(begin());
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::const_reverse_iterator
deque<T, Allocator>::rend() const
{
	return const_reverse_iterator(begin());
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::size_type
deque<T, Allocator>::size() const
{
	return size_;
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::size_type
deque<T, Allocator>::max_size() const
{
	return alloc_.max_size();
}

template <class T, class Allocator>
void
deque<T, Allocator>::resize(size_type sz, T c)
{
	if (sz > size())
		insert(end(), sz-size(), c);
	else if (sz < size())
		erase(begin() + difference_type(sz), end());
}

template <class T, class Allocator>
inline
bool
deque<T, Allocator>::empty() const
{
	return size_ == 0;
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::reference
deque<T, Allocator>::operator[](size_type n)
{
	size_type i = n + start_;
	return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::const_reference
deque<T, Allocator>::operator[](size_type n) const
{
	size_type i = n + start_;
	return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template <class T, class Allocator>
typename deque<T, Allocator>::reference
deque<T, Allocator>::at(size_type n)
{
	if (n >= size_)
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("deque::at index out of range");
		#else
		{
			fprintf(stderr, "deque::at index out of range");
			abort();
		}
		#endif
	size_type i = n + start_;
	return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template <class T, class Allocator>
typename deque<T, Allocator>::const_reference
deque<T, Allocator>::at(size_type n) const
{
	if (n >= size_)
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("deque::at index out of range");
		#else
		{
			fprintf(stderr, "deque::at index out of range");
			abort();
		}
		#endif
	size_type i = n + start_;
	return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::reference
deque<T, Allocator>::front()
{
	return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::const_reference
deque<T, Allocator>::front() const
{
	return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::reference
deque<T, Allocator>::back()
{
	size_type i = start_ + size_ - 1;
	return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::const_reference
deque<T, Allocator>::back() const
{
	size_type i = start_ + size_ - 1;
	return *(buf_[i / alloc_.m_] + i % alloc_.m_);
}

template <class T, class Allocator>
void
deque<T, Allocator>::push_front(const T& x)
{
	if (size_ > max_size() - 1)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("deque::push_front length error");
		#else
		{
			fprintf(stderr, "deque::push_front length error\n");
			abort();
		}
		#endif
	if (buf_.empty())
		init_buf();
	size_type new_buffers = 0;
	size_type oldstart = start_;
	buf_type orig_buf;
	bool buf_invalidated = false;
	if (start_ == 0)
		buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, 1);
	else
		--start_;
	#ifndef _MSL_NO_EXCEPTIONS
	try
	{
	#endif
		if (start_ < alloc_.m_)
			new (buf_.front() + start_) value_type(x);
		else
			new (buf_[start_ / alloc_.m_] + start_ % alloc_.m_) value_type(x);
		++size_;
	#ifndef _MSL_NO_EXCEPTIONS
	}
	catch (...)
	{
		if (new_buffers)
		{
			alloc_.deallocate(buf_.front(), alloc_.m_);
			buf_.pop_front();
		}
		if (buf_invalidated)
			buf_.swap(orig_buf);
		start_ = oldstart;
		throw;
	}
	#endif
	invalidate_iterators();
}

template <class T, class Allocator>
void
deque<T, Allocator>::push_back(const T& x)
{
	if (size_ > max_size() - 1)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("deque::push_back length error");
		#else
		{
			fprintf(stderr, "deque::push_back length error\n");
			abort();
		}
		#endif
	if (buf_.empty())
		init_buf();
	{
		size_type new_buffers = 0;
		buf_type orig_buf;
		bool buf_invalidated = false;
		if (capacity() == start_ + size_)
			buf_invalidated = grow_buf_back(0, orig_buf, new_buffers, 1);
		size_type pos = start_ + size_;
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			if (pos < alloc_.m_)
				new (buf_.front() + pos) value_type(x);
			else
				new (buf_[pos / alloc_.m_] + pos % alloc_.m_) value_type(x);
			++size_;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
			if (buf_invalidated)
				buf_.swap(orig_buf);
			throw;
		}
		#endif
	}
	invalidate_iterators();
}

template <class T, class Allocator>
typename deque<T, Allocator>::iterator
deque<T, Allocator>::insert(iterator position, const T& x)
{
	difference_type pos = position - begin();
	insert(position, 1, x);
	return begin() + pos;
}

template <class T, class Allocator>
void
deque<T, Allocator>::insert(iterator position, size_type n, const T& x)
{
	if (n == 0)
		return;
	size_type ms = max_size();
	if (n > ms || size_ > ms - n)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("deque::insert length error");
		#else
		{
			fprintf(stderr, "deque::insert length error\n");
			abort();
		}
		#endif
	if (buf_.empty())
		init_buf();
	size_type pb = position.pos_ - start_;
	size_type pe = size_ - pb;
	if (pb <= pe)  // hh 981210
	{
		size_type new_buffers = 0;
		size_type oldstart = start_;
		buf_type orig_buf;
		bool buf_invalidated = false;
		if (start_ < n)
			buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
		else
			start_ -= n;
		size_type done = 0;
		iterator beg = begin();
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			if (pb == 0) // insert at begin()
				uninitialized_fill_n(beg, n, x);
			else // pos in [1, size_ / 2)
			{
				iterator b_n = beg + difference_type(n);
				iterator b_n_pb = b_n + difference_type(pb);
				iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
				iterator t;
				if (pb > n)
					t = beg + difference_type(2*n);
				else
					t = b_n_pb;
				uninitialized_copy(b_n, t, beg);
				if (pb > n)
				{
					done = n;
					copy(t, b_n_pb, b_n);
					t = b_pb;
				}
				else if (pb < n)
				{
					done = pb;
					uninitialized_fill(b_pb, b_n, x);
					done = n;
					t = b_n;
				}
				else
				{
					done = n;
					t = b_n;
				}
				fill(t, b_n_pb, x);
			}
			size_ += n;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			destroy(beg, beg + difference_type(done));
			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
			{
				alloc_.deallocate(buf_.front(), alloc_.m_);
				buf_.pop_front();
			}
			if (buf_invalidated)
				buf_.swap(orig_buf);
			start_ = oldstart;
			throw;
		}
		#endif
	}
	else // pos >= size_ / 2
	{
		size_type new_buffers = 0;
		buf_type orig_buf;
		bool buf_invalidated = false;
		size_type e = capacity() - (start_ + size_);
		bool done = false;
		if (e < n)
			buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
		iterator t2;
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			if (pe == 0) // insert at end()
				uninitialized_fill_n(end(), n, x);
			else // pos in [size_ / 2, size_)
			{
				iterator ei = end();
				iterator e_n = ei - difference_type(n);
				iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
				iterator t1;
				if (pe >= n)
				{
					t1 = e_n;
					t2 = ei;
				}
				else
				{
					t1 = e_pe;
					t2 = ei + difference_type(n - pe);
				}
				uninitialized_copy(t1, ei, t2);
				done = true;
				if (pe >= n)
				{
					if (pe > n)
						copy_backward(e_pe, e_n, ei);
					t1 = pe == n ? ei : ei - difference_type(pe - n);
					fill(e_pe, t1, x);
				}
				else if (n > pe)
				{
					fill(e_pe, ei, x);
					uninitialized_fill(ei, t2, x);
				}
			}
			size_ += n;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			if (done)
				destroy(t2, end() + difference_type(n));
			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
			if (buf_invalidated)
				buf_.swap(orig_buf);
			throw;
		}
		#endif
	}
	invalidate_iterators();
}

#ifdef _MSL_NO_MEMBER_TEMPLATE

	template <class T, class Allocator>
	void
	deque<T, Allocator>::insert(iterator position, const_iterator first, const_iterator last)
	{
		size_type n = (size_type)distance(first, last);
		if (n == 0)
			return;
		size_type ms = max_size();
		if (n > ms || size_ > ms - n)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::insert length error");
			#else
			{
				fprintf(stderr, "deque::insert length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		size_type pb = position.pos_ - start_;
		size_type pe = size_ - pb;
		if (pb <= pe)  // hh 981210
		{
			size_type new_buffers = 0;
			size_type oldstart = start_;
			buf_type orig_buf;
			bool buf_invalidated = false;
			if (start_ < n)
				buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
			else
				start_ -= n;
			size_type done = 0;
			iterator beg = begin();
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				if (pb == 0) // insert at begin()
					uninitialized_copy(first, last, beg);
				else // pos in [1, size_ / 2)
				{
					iterator b_n = beg + difference_type(n);
					iterator b_n_pb = b_n + difference_type(pb);
					iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
					iterator t;
					if (pb > n)
						t = beg + difference_type(2*n);
					else
						t = b_n_pb;
					uninitialized_copy(b_n, t, beg);
					const_iterator i = first;
					if (pb > n)
					{
						done = n;
						copy(t, b_n_pb, b_n);
						t = b_pb;
					}
					else if (pb < n)
					{
						done = pb;
						advance(i, difference_type(n - pb));
						uninitialized_copy(first, i, b_pb);
						done = n;
						t = b_n;
					}
					else
					{
						done = n;
						t = b_n;
					}
					copy(i, last, t);
				}
				size_ += n;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				destroy(beg, beg + difference_type(done));
				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
				{
					alloc_.deallocate(buf_.front(), alloc_.m_);
					buf_.pop_front();
				}
				if (buf_invalidated)
					buf_.swap(orig_buf);
				start_ = oldstart;
				throw;
			}
			#endif
		}
		else // pos >= size_ / 2
		{
			size_type new_buffers = 0;
			buf_type orig_buf;
			bool buf_invalidated = false;
			size_type e = capacity() - (start_ + size_);
			bool done = false;
			if (e < n)
				buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
			iterator t2;
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				if (pe == 0) // insert at end()
					uninitialized_copy(first, last, end());
				else // pos in [size_ / 2, size_)
				{
					iterator ei = end();
					iterator e_n = ei - difference_type(n);
					iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
					iterator t1;
					if (pe >= n)
					{
						t1 = e_n;
						t2 = ei;
					}
					else
					{
						t1 = e_pe;
						t2 = ei + difference_type(n - pe);
					}
					uninitialized_copy(t1, ei, t2);
					done = true;
					if (pe >= n)
					{
						if (pe > n)
							copy_backward(e_pe, e_n, ei);
						copy(first, last, e_pe);
					}
					else if (n > pe)
					{
						const_iterator i = first;
						advance(i, difference_type(pe));
						copy(first, i, e_pe);
						uninitialized_copy(i, last, ei);
					}
				}
				size_ += n;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				if (done)
					destroy(t2, end() + difference_type(n));
				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
				{
					buf_.pop_back();
					pointer& p = buf_.back();
					alloc_.deallocate(p, alloc_.m_);
					p = 0;
				}
				if (buf_invalidated)
					buf_.swap(orig_buf);
				throw;
			}
			#endif
		}
		invalidate_iterators();
	}

	template <class T, class Allocator>
	void
	deque<T, Allocator>::insert(iterator position, const value_type* first, const value_type* last)
	{
		size_type n = (size_type)distance(first, last);
		if (n == 0)
			return;
		size_type ms = max_size();
		if (n > ms || size_ > ms - n)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::insert length error");
			#else
			{
				fprintf(stderr, "deque::insert length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		size_type pb = position.pos_ - start_;
		size_type pe = size_ - pb;
		if (pb <= pe)  // hh 981210
		{
			size_type new_buffers = 0;
			size_type oldstart = start_;
			buf_type orig_buf;
			bool buf_invalidated = false;
			if (start_ < n)
				buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);
			else
				start_ -= n;
			size_type done = 0;
			iterator beg = begin();
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				if (pb == 0) // insert at begin()
					uninitialized_copy(first, last, beg);
				else // pos in [1, size_ / 2)
				{
					iterator b_n = beg + difference_type(n);
					iterator b_n_pb = b_n + difference_type(pb);
					iterator b_pb = pb == n ? b_n : beg + difference_type(pb);
					iterator t;
					if (pb > n)
						t = beg + difference_type(2*n);
					else
						t = b_n_pb;
					uninitialized_copy(b_n, t, beg);
					const value_type* i = first;
					if (pb > n)
					{
						done = n;
						copy(t, b_n_pb, b_n);
						t = b_pb;
					}
					else if (pb < n)
					{
						done = pb;
						advance(i, difference_type(n - pb));
						uninitialized_copy(first, i, b_pb);
						done = n;
						t = b_n;
					}
					else
					{
						done = n;
						t = b_n;
					}
					copy(i, last, t);
				}
				size_ += n;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				destroy(beg, beg + difference_type(done));
				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
				{
					alloc_.deallocate(buf_.front(), alloc_.m_);
					buf_.pop_front();
				}
				if (buf_invalidated)
					buf_.swap(orig_buf);
				start_ = oldstart;
				throw;
			}
			#endif
		}
		else // pos >= size_ / 2
		{
			size_type new_buffers = 0;
			buf_type orig_buf;
			bool buf_invalidated = false;
			size_type e = capacity() - (start_ + size_);
			bool done = false;
			if (e < n)
				buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);
			iterator t2;
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				if (pe == 0) // insert at end()
					uninitialized_copy(first, last, end());
				else // pos in [size_ / 2, size_)
				{
					iterator ei = end();
					iterator e_n = ei - difference_type(n);
					iterator e_pe = pe == n ? e_n : ei - difference_type(pe);
					iterator t1;
					if (pe >= n)
					{
						t1 = e_n;
						t2 = ei;
					}
					else
					{
						t1 = e_pe;
						t2 = ei + difference_type(n - pe);
					}
					uninitialized_copy(t1, ei, t2);
					done = true;
					if (pe >= n)
					{
						if (pe > n)
							copy_backward(e_pe, e_n, ei);
						copy(first, last, e_pe);
					}
					else if (n > pe)
					{
						const value_type* i = first;
						advance(i, difference_type(pe));
						copy(first, i, e_pe);
						uninitialized_copy(i, last, ei);
					}
				}
				size_ += n;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				if (done)
					destroy(t2, end() + difference_type(n));
				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
				{
					buf_.pop_back();
					pointer& p = buf_.back();
					alloc_.deallocate(p, alloc_.m_);
					p = 0;
				}
				if (buf_invalidated)
					buf_.swap(orig_buf);
				throw;
			}
			#endif
		}
		invalidate_iterators();
	}

#endif

template <class T, class Allocator>
void
deque<T, Allocator>::pop_front()
{
	_STD::destroy(&front());
	++start_;
	if (--size_ == 0)
	{
		for (size_type i = buf_.size() - 2; i > 0; --i)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
		}
		start_ = alloc_.m_ / 2;
	}
}

template <class T, class Allocator>
void
deque<T, Allocator>::pop_back()
{
	_STD::destroy(&back());
	--size_;
	while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)
	{
		buf_.pop_back();
		pointer& p = buf_.back();
		alloc_.deallocate(p, alloc_.m_);
		p = 0;
	}
	if (size_ == 0)
	{
		for (size_type i = buf_.size() - 2; i > 0; --i)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
		}
		start_ = alloc_.m_ / 2;
	}
}

template <class T, class Allocator>
inline
typename deque<T, Allocator>::iterator
deque<T, Allocator>::erase(iterator position)
{
	return erase(position, position + 1);
}

template <class T, class Allocator>
typename deque<T, Allocator>::iterator
deque<T, Allocator>::erase(iterator first, iterator last)
{
	if (first == last)
		return first;
	const size_type pb = first.pos_ - start_;
	const size_type pe = size_ - (last.pos_ - start_);
	const size_type diff = size_type(last - first);
	if (pb < pe)
	{
		if (pb == 0)  // erase from beginning, no copying necessary
		{
			destroy(first, last);
			start_ += diff;
			size_ -= diff;
		}
		else  // erase from beginning, needs copying
		{
			iterator bi = begin();
			copy_backward(bi, first, last);
			destroy(bi, bi + difference_type(diff));
			start_ += diff;
			size_ -= diff;
			invalidate_iterators();
		}
	}
	else  // pb >= pe - erase from end
	{
		if (pe == 0)  // erase from end, no copying necessary
			destroy(first, last);
		else  // erase from end, needs copying
		{
			iterator ei = end();
			copy(last, ei, first);
			destroy(first + difference_type(pe), ei);
			invalidate_iterators();
		}
		size_ -= diff;
		while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
		}
	}
	if (size_ == 0)
	{
		for (size_type i = buf_.size() - 2; i > 0; --i)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
		}
		start_ = alloc_.m_ / 2;
	}
	return make_iterator(start_ + pb);
}

template <class T, class Allocator>
void
deque<T, Allocator>::swap(deque<T,Allocator>& x)
{
	if (this != &x)
	{
		_STD::swap(alloc_, x.alloc_);
		_STD::swap(buf_, x.buf_);
		_STD::swap(start_, x.start_);
		_STD::swap(size_, x.size_);
	}
}

template <class T, class Allocator>
void
deque<T, Allocator>::clear()
{
	if (!buf_.empty())  // hh 981209
	{
		destroy(begin(), end());
		size_ = 0;
		for (size_type i = buf_.size() - 2; i > 0; --i)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
		}
		start_ = alloc_.m_ / 2;
	}
}

template <class T, class Allocator>
inline
bool
operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y)
{
	return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
}

template <class T, class Allocator>
inline
bool
operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y)
{
	return !(x == y);
}

template <class T, class Allocator>
inline
bool
operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y)
{
	return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
}

template <class T, class Allocator>
inline
bool
operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y)
{
	return y < x;
}

template <class T, class Allocator>
inline
bool
operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y)
{
	return !(x < y);
}

template <class T, class Allocator>
inline
bool
operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y)
{
	return !(y < x);
}

template <class T, class Allocator>
inline
void
swap(deque<T,Allocator>& x, deque<T,Allocator>& y)
{
	x.swap(y);
}

#if !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)

	// Specialize for T* to save on code bloat

	// void*

	template <class Allocator>
	class deque<void*, Allocator>
	{
		template <bool b> struct chooser {};
	public:
		// types:
		typedef typename Allocator::reference         reference;
		typedef typename Allocator::const_reference   const_reference;
		class                                         iterator;
		class                                         const_iterator;
		typedef typename Allocator::size_type         size_type;
		typedef typename Allocator::difference_type   difference_type;
		typedef void*                                 value_type;
		typedef Allocator                             allocator_type;
		typedef typename Allocator::pointer           pointer;
		typedef typename Allocator::const_pointer     const_pointer;
		typedef _STD::reverse_iterator<iterator>       reverse_iterator;
		typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;
	private:
		typedef _MSL_REBIND (pointer) buf_allocator;
		typedef __cdeque<pointer, buf_allocator> buf_type;
	public:
		friend class iterator;
		class iterator
			: public _STD::iterator<random_access_iterator_tag, value_type, difference_type, pointer, reference>
		{
		public:
			iterator() {}
			reference operator * () const {return *cur_;}
			pointer operator -> () const {return cur_;}
			iterator& operator ++ ()
			{
				++pos_;
				if (++cur_ == end_)
				{
					difference_type buf_size = end_ - *beg_;
					++beg_;
					pointer beg = *beg_;
					cur_ = beg;
					end_ = beg + buf_size;
				}
				return *this;
			}
			iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}
			iterator& operator -- ()
			{
				--pos_;
				pointer beg = *beg_;
				if (cur_ != beg)
					--cur_;
				else
				{
					difference_type buf_size = end_ - beg;
					--beg_;
					end_ = *beg_ + buf_size;
					cur_ = end_ - 1;
				}
				return *this;
			}
			iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}
			iterator& operator += (difference_type n)
			{
				if (n < 0)
					return (*this) -= -n;
				pos_ += n;
				difference_type room = end_ - cur_ ;
				if (n < room)
					cur_ += n;
				else
				{
					difference_type buf_size = end_ - *beg_;
					n -= room;
					beg_ += n / buf_size + 1;
					pointer beg = *beg_;
					cur_ = beg + n % buf_size;
					end_ = beg + buf_size;
				}
				return *this;
			}
			iterator operator + (difference_type n) const {return iterator(*this) += n;}
			iterator& operator -= (difference_type n)
			{
				if (n < 0)
					return (*this) += -n;
				pos_ -= n;
				pointer beg = *beg_;
				difference_type room = cur_ - beg + 1;
				if (n < room)
					cur_ -= n;
				else
				{
					difference_type buf_size = end_ - beg;
					n -= room;
					beg_ -= n / buf_size + 1;
					end_ = *beg_ + buf_size;
					cur_ = end_ - 1 - n % buf_size;
				}
				return *this;
			}
			iterator operator - (difference_type n) const {return iterator(*this) -= n;}
			difference_type operator - (const iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}
			reference operator [] (size_type i) const {iterator tmp(*this); tmp += difference_type(i); return *tmp;}
			bool operator ==(const iterator& rhs) const {return cur_ == rhs.cur_;}
			bool operator !=(const iterator& rhs) const {return cur_ != rhs.cur_;}
			bool operator < (const iterator& rhs) const {return pos_ <  rhs.pos_;}
			bool operator <=(const iterator& rhs) const {return pos_ <= rhs.pos_;}
			bool operator > (const iterator& rhs) const {return pos_ >  rhs.pos_;}
			bool operator >=(const iterator& rhs) const {return pos_ >= rhs.pos_;}
			friend iterator operator + (difference_type n, const iterator& rhs)
				{return iterator(rhs) += n;}
		private:
			buf_type::iterator beg_;
			pointer cur_;
			pointer end_;
			size_type pos_;

			iterator(const buf_type::iterator& beg, pointer cur, pointer end, size_type pos)
				: beg_(beg),
				  cur_(cur),
				  end_(end),
				  pos_(pos)
			{}

			friend class deque;
			friend class deque::const_iterator;
		};

		friend class const_iterator;
		class const_iterator
			: public _STD::iterator<random_access_iterator_tag, value_type, difference_type, const_pointer, const_reference>
		{
		public:
			const_iterator() {}
			const_iterator(const deque::iterator& rhs) : beg_(rhs.beg_), cur_(rhs.cur_), end_(rhs.end_), pos_(rhs.pos_) {}
			const_reference operator * () const {return *cur_;}
			const_pointer operator -> () const {return cur_;}
			const_iterator& operator ++ ()
			{
				++pos_;
				if (++cur_ == end_)
				{
					difference_type buf_size = end_ - *beg_;
					++beg_;
					pointer beg = *beg_;
					cur_ = beg;
					end_ = beg + buf_size;
				}
				return *this;
			}
			const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}
			const_iterator& operator -- ()
			{
				--pos_;
				pointer beg = *beg_;
				if (cur_ != beg)
					--cur_;
				else
				{
					difference_type buf_size = end_ - beg;
					--beg_;
					end_ = *beg_ + buf_size;
					cur_ = end_ - 1;
				}
				return *this;
			}
			const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}
			const_iterator& operator += (difference_type n)
			{
				if (n < 0)
					return (*this) -= -n;
				pos_ += n;
				difference_type room = end_ - cur_ ;
				if (n < room)
					cur_ += n;
				else
				{
					difference_type buf_size = end_ - *beg_;
					n -= room;
					beg_ += n / buf_size + 1;
					pointer beg = *beg_;
					cur_ = beg + n % buf_size;
					end_ = beg + buf_size;
				}
				return *this;
			}
			const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}
			const_iterator& operator -= (difference_type n)
			{
				if (n < 0)
					return (*this) += -n;
				pos_ -= n;
				pointer beg = *beg_;
				difference_type room = cur_ - beg + 1;
				if (n < room)
					cur_ -= n;
				else
				{
					difference_type buf_size = end_ - beg;
					n -= room;
					beg_ -= n / buf_size + 1;
					end_ = *beg_ + buf_size;
					cur_ = end_ - 1 - n % buf_size;
				}
				return *this;
			}
			const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}
			difference_type operator - (const const_iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}
			const_reference operator [] (size_type i) const {const_iterator tmp(*this); tmp += difference_type(i); return *tmp;}
			bool operator ==(const const_iterator& rhs) const {return cur_ == rhs.cur_;}
			bool operator !=(const const_iterator& rhs) const {return cur_ != rhs.cur_;}
			bool operator < (const const_iterator& rhs) const {return pos_ <  rhs.pos_;}
			bool operator <=(const const_iterator& rhs) const {return pos_ <= rhs.pos_;}
			bool operator > (const const_iterator& rhs) const {return pos_ >  rhs.pos_;}
			bool operator >=(const const_iterator& rhs) const {return pos_ >= rhs.pos_;}
			friend const_iterator operator + (difference_type n, const const_iterator& rhs)
				{return const_iterator(rhs) += n;}
		private:
			buf_type::const_iterator beg_;
			const_pointer cur_;
			const_pointer end_;
			size_type pos_;

			const_iterator(const buf_type::const_iterator& beg, const_pointer cur, const_pointer end, size_type pos)
				: beg_(beg),
				  cur_(cur),
				  end_(end),
				  pos_(pos)
			{}

			friend class deque;
		};

		// _lib.deque.cons_ construct/copy/destroy:
		explicit deque(const Allocator& = Allocator());
		explicit deque(size_type n, const value_type& value = 0, const Allocator& = Allocator());
		template <class InputIterator>
			deque(InputIterator first, InputIterator last, const Allocator& a = Allocator())
				: alloc_(a, default_bufsize_s),
				  buf_(buf_allocator(a)),
				  start_(0),
				  size_(0)
			{
				choose_init(first, last, chooser<numeric_limits<InputIterator>::is_integer>());
			}
		deque(const deque& x);
		~deque();
		deque& operator=(const deque& x);
		template <class InputIterator>
			inline
			void assign(InputIterator first, InputIterator last)
			{
				choose_assign(first, last, chooser<numeric_limits<InputIterator>::is_integer>());
			}
		void assign(size_type n, const value_type& t);
		allocator_type get_allocator() const;
		// iterators:
		iterator               begin();
		const_iterator         begin() const;
		iterator               end();
		const_iterator         end() const;
		reverse_iterator       rbegin();
		const_reverse_iterator rbegin() const;
		reverse_iterator       rend();
		const_reverse_iterator rend() const;
		// _lib.deque.capacity_ capacity:
		size_type size() const;
		size_type max_size() const;
		void      resize(size_type sz, value_type c = 0);
		bool      empty() const;

		// element access:
		reference       operator[](size_type n);
		const_reference operator[](size_type n) const;
		reference       at(size_type n);
		const_reference at(size_type n) const;
		reference       front();
		const_reference front() const;
		reference       back();
		const_reference back() const;
		// _lib.deque.modifiers_ modifiers:
		void push_front(const value_type& x);
		void push_back(const value_type& x);
		iterator insert(iterator position, const value_type& x);
		void     insert(iterator position, size_type n, const value_type& x);
		template <class InputIterator>
			inline
			void insert(iterator position, InputIterator first, InputIterator last)
			{
				choose_insert(position, first, last, chooser<numeric_limits<InputIterator>::is_integer>());
			}
		void pop_front();
		void pop_back();
		iterator erase(iterator position);
		iterator erase(iterator first, iterator last);
		void     swap(deque&);
		void     clear();
	private:
		static const size_type min_buf_size_s = 8;
		static const size_type min_foot_print_s = 512;
		static const size_type default_bufsize_s = sizeof(value_type) * min_buf_size_s < min_foot_print_s ?
		                                           min_foot_print_s / sizeof(value_type) : min_buf_size_s;
		_EmptyMemberOpt<Allocator, size_type> alloc_;  // alloc_.m_ is bufsize_
		buf_type buf_;
		size_type start_;
		size_type size_;

		template <class InputIterator>
			inline
			void
			choose_init(InputIterator first, InputIterator last, chooser<true>)
			{
				init(static_cast<size_type>(first), reinterpret_cast<value_type>(last));  // hh 981208
			}

		template <class InputIterator>
			inline
			void
			choose_init(InputIterator first, InputIterator last, chooser<false>)
			{
				init(first, last, iterator_traits<InputIterator>::iterator_category());
			}

		template <class InputIterator>
			void
			init(InputIterator first, InputIterator last, input_iterator_tag)
			{
				#ifndef _MSL_NO_EXCEPTIONS
				try
				{
				#endif
					for (; first != last; ++first)
						push_back(*first);
				#ifndef _MSL_NO_EXCEPTIONS
				}
				catch (...)
				{
					tear_down();
					throw;
				}
				#endif
			}

		template <class ForwardIterator>
			void
			init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
			{
				size_ = (size_type)distance(first, last);
				if (size_ > max_size())
					#ifndef _MSL_NO_EXCEPTIONS
						throw length_error("deque::construction length error");
					#else
					{
						fprintf(stderr, "deque::construction length error\n");
						abort();
					}
					#endif
				if (size_ > 0)
				{
					init_buf();
					if (alloc_.m_ < size_)
						alloc_.m_ = size_;
					pointer tmp = alloc_.allocate(alloc_.m_);
					#ifndef _MSL_NO_EXCEPTIONS
					try
					{
					#endif
						buf_.front() = tmp;
						buf_.push_back(0);
						start_ = (alloc_.m_ - size_) / 2;
						copy(first, last, tmp + start_);
					#ifndef _MSL_NO_EXCEPTIONS
					}
					catch (...)
					{
						alloc_.deallocate(tmp, alloc_.m_);
						throw;
					}
					#endif
				}
			}

		template <class InputIterator>
			inline
			void
			choose_assign(InputIterator first, InputIterator last, chooser<true>)
			{
				assign(static_cast<size_type>(first), static_cast<value_type>(last));
			}

		template <class InputIterator>
			inline
			void
			choose_assign(InputIterator first, InputIterator last, chooser<false>)
			{
				do_assign(first, last, iterator_traits<InputIterator>::iterator_category());
			}

		template <class InputIterator>
			void
			do_assign(InputIterator first, InputIterator last, input_iterator_tag)
			{
				deque temp(first, last, get_allocator());
				const deque& tempr = temp;
				do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
			}

		template <class ForwardIterator>
			void
			do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
			{
				size_type n = (size_type)distance(first, last);
				if (n > max_size())
					#ifndef _MSL_NO_EXCEPTIONS
						throw length_error("deque::assign length error");
					#else
					{
						fprintf(stderr, "deque::assign length error\n");
						abort();
					}
					#endif
				if (buf_.empty())
					init_buf();
				while (n > capacity())
				{
					pointer tmp = alloc_.allocate(alloc_.m_);
					#ifndef _MSL_NO_EXCEPTIONS
					try
					{
					#endif
						buf_.back() = tmp;
						buf_.push_back(0);
					#ifndef _MSL_NO_EXCEPTIONS
					}
					catch (...)
					{
						alloc_.deallocate(tmp, alloc_.m_);
						throw;
					}
					#endif
				}
				start_ = (capacity() - n) / 2;
				while (start_ >= alloc_.m_)
				{
					buf_.pop_back();
					pointer& p = buf_.back();
					alloc_.deallocate(p, alloc_.m_);
					p = 0;
					start_ = (capacity() - n) / 2;
				}
				copy(first, last, begin());
				size_ = n;
			}

		template <class InputIterator>
			inline
			void
			choose_insert(iterator position, InputIterator first, InputIterator last,
				chooser<true>)
			{
				insert(position, static_cast<size_type>(first), static_cast<value_type>(last));
			}

		template <class InputIterator>
			inline
			void
			choose_insert(iterator position, InputIterator first, InputIterator last,
				chooser<false>)
			{
				do_insert(position, first, last, iterator_traits<InputIterator>::iterator_category());
			}

		template <class InputIterator>
			void
			do_insert(iterator position, InputIterator first, InputIterator last,
				input_iterator_tag)
			{
				deque temp(first, last, get_allocator());
				const deque& tempr = temp;
				do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());
			}

		template <class ForwardIterator>
			void
			do_insert(iterator position, ForwardIterator first, ForwardIterator last,
				forward_iterator_tag)
			{
				size_type n = (size_type)distance(first, last);
				if (n == 0)
					return;
				size_type ms = max_size();
				if (n > ms || size_ > ms - n)
					#ifndef _MSL_NO_EXCEPTIONS
						throw length_error("deque::insert length error");
					#else
					{
						fprintf(stderr, "deque::insert length error\n");
						abort();
					}
					#endif
				if (buf_.empty())
					init_buf();
				size_type pb = position.pos_ - start_;
				size_type pe = size_ - pb;
				if (pb <= pe)  // hh 981210
				{
					if (start_ < n)
						grow_buf_front(n);
					else
						start_ -= n;
					if (pb == 0) // insert at begin()
						copy(first, last, begin());
					else // pos in [1, size_ / 2)
					{
						iterator b = begin();
						copy(b + difference_type(n), b + difference_type(n + pb), b);
						copy(first, last, b + difference_type(pb));
					}
					size_ += n;
				}
				else // pos >= size_ / 2
				{
					size_type e = capacity() - (start_ + size_);
					if (e < n)
						grow_buf_back(e, n);
					if (pe == 0) // insert at end()
						copy(first, last, end());
					else // pos in [size_ / 2, size_)
					{
						iterator e = end();
						iterator p = e - difference_type(pe);
						copy_backward(p, e, e + difference_type(n));
						copy(first, last, p);
					}
					size_ += n;
				}
				invalidate_iterators();
			}

		void init(size_type n, const value_type& value);
		void tear_down();
		void invalidate_iterators();
		iterator make_iterator(size_type pos);
		const_iterator make_iterator(size_type pos) const;
		void init_buf();
		size_type capacity() const;
		void grow_buf_front(size_type n);
		void grow_buf_back(size_type e, size_type n);
	};

	// Implementation deque<void*>

	template <class Allocator>
	inline
	void
	deque<void*, Allocator>::invalidate_iterators()
	{
		while (start_ >= 3 * alloc_.m_ / 2)
		{
			alloc_.deallocate(buf_.front(), alloc_.m_);
			buf_.pop_front();
			start_ -= alloc_.m_;
		}
	}

	template <class Allocator>
	typename deque<void*, Allocator>::iterator
	deque<void*, Allocator>::make_iterator(size_type pos)
	{
		buf_type::iterator b = buf_.begin();
		pointer cur;
		pointer beg;
		if (pos < alloc_.m_)
		{
			if (!buf_.empty())
				beg = *b;
			else
				beg = 0;
			cur = beg + pos;
		}
		else
		{
			b += difference_type(pos / alloc_.m_);
			beg = *b;
			cur = beg + pos % alloc_.m_;
		}
		return iterator(b, cur, beg + alloc_.m_, pos);
	}

	template <class Allocator>
	typename deque<void*, Allocator>::const_iterator
	deque<void*, Allocator>::make_iterator(size_type pos) const
	{
		buf_type::const_iterator b = buf_.begin();
		const_pointer cur;
		const_pointer beg;
		if (pos < alloc_.m_)
		{
			if (!buf_.empty())
				beg = *b;
			else
				beg = 0;
			cur = beg + pos;
		}
		else
		{
			b += difference_type(pos / alloc_.m_);
			beg = *b;
			cur = beg + pos % alloc_.m_;
		}
		return const_iterator(b, cur, beg + alloc_.m_, pos);
	}

	template <class Allocator>
	inline
	void
	deque<void*, Allocator>::init_buf()
	{
		buf_.reserve(2);
		buf_.resize(1);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::size_type
	deque<void*, Allocator>::capacity() const
	{
		return (buf_.size() - 1) * alloc_.m_;
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::grow_buf_front(size_type n)
	{
		bool buf_invalidated = false;
		size_type oldstart = start_;
		size_type new_buffers = 0;
		buf_type orig_buf;
		size_type nc = n;
		nc -= start_;
		while (true)
		{
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				if (!buf_invalidated && buf_.size() == buf_.capacity())
				{
					buf_.swap(orig_buf);
					buf_invalidated = true;
					buf_.reserve(2*orig_buf.capacity());
					buf_.assign(orig_buf.begin(), orig_buf.end());
				}
				buf_.push_front(tmp);
				++new_buffers;  // hh 981210
				start_ += alloc_.m_;
				if (nc <= alloc_.m_)
				{
					if (size_ != 0)  // hh 981210
						start_ -= n;
					else
						start_ = (capacity() - n) / 2;
					break;
				}
				nc -= alloc_.m_;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
				{
					alloc_.deallocate(buf_.front(), alloc_.m_);
					buf_.pop_front();
				}
				if (buf_invalidated)
					buf_.swap(orig_buf);
				start_ = oldstart;
				throw;
			}
			#endif
		}
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::grow_buf_back(size_type e, size_type n)
	{
		bool buf_invalidated = false;
		buf_type orig_buf;
		size_type new_buffers = 0;
		size_type nc = n;
		nc -= e;
		while (true)
		{
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				if (!buf_invalidated && buf_.size() == buf_.capacity())
				{
					buf_.swap(orig_buf);
					buf_invalidated = true;
					buf_.reserve(2*orig_buf.capacity());
					buf_.assign(orig_buf.begin(), orig_buf.end());
				}
				buf_.back() = tmp;
				buf_.push_back(0);
				++new_buffers;
				if (nc <= alloc_.m_)
					break;
				nc -= alloc_.m_;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				if (!buf_.empty())	// 990315 hh
					buf_.back() = 0;
				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210
				{
					buf_.pop_back();
					pointer& p = buf_.back();
					alloc_.deallocate(p, alloc_.m_);
					p = 0;
				}
				if (buf_invalidated)
					buf_.swap(orig_buf);
				throw;
			}
			#endif
		}
	}

	template <class Allocator>
	deque<void*, Allocator>::deque(const Allocator& a)
		: alloc_(a, default_bufsize_s),
		  buf_(buf_allocator(a)),
		  start_(0),
		  size_(0)
	{
	}

	template <class Allocator>
	deque<void*, Allocator>::deque(size_type n, const value_type& value, const Allocator& a)
		: alloc_(a, default_bufsize_s),
		  buf_(buf_allocator(a)),
		  start_(0),
		  size_(0)
	{
		init(n, value);
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::init(size_type n, const value_type& value)
	{
		if (n > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::construction length error");
			#else
			{
				fprintf(stderr, "deque::construction length error\n");
				abort();
			}
			#endif
		if (n > 0)
		{
			init_buf();
			if (alloc_.m_ < n)
				alloc_.m_ = n;
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				buf_.front() = tmp;
				buf_.push_back(0);
				size_ = n;
				start_ = (alloc_.m_ - size_) / 2;
				fill_n(tmp + start_, size_, value);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				throw;
			}
			#endif
		}
	}

	template <class Allocator>
	deque<void*, Allocator>::deque(const deque& x)
		: alloc_(x.alloc_, default_bufsize_s),
		  buf_(buf_allocator(alloc_)),
		  start_(0),
		  size_(x.size_)
	{
		if (size_ > 0)
		{
			init_buf();
			if (alloc_.m_ < size_)
				alloc_.m_ = size_;
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				buf_.front() = tmp;
				buf_.push_back(0);
				start_ = (alloc_.m_ - size_) / 2;
				copy(x.begin(), x.end(), tmp + start_);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				throw;
			}
			#endif
		}
	}

	template <class Allocator>
	inline
	deque<void*, Allocator>::~deque()
	{
		tear_down();
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::tear_down()
	{
		if (!buf_.empty())
		{
			buf_type::iterator e = --buf_.end();
			for (buf_type::iterator i = buf_.begin(); i != e; ++i)
				alloc_.deallocate(*i, alloc_.m_);
		}
	}

	template <class Allocator>
	deque<void*,Allocator>&
	deque<void*, Allocator>::operator=(const deque& x)
	{
		if (this != &x)
			assign(x.begin(), x.end());
		return *this;
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::assign(size_type n, const value_type& t)
	{
		if (n > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::assign length error");
			#else
			{
				fprintf(stderr, "deque::assign length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		while (n > capacity())
		{
			pointer tmp = alloc_.allocate(alloc_.m_);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				buf_.back() = tmp;
				buf_.push_back(0);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(tmp, alloc_.m_);
				buf_.back() = 0;
				throw;
			}
			#endif
		}
		start_ = (capacity() - n) / 2;
		while (start_ >= alloc_.m_)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
			start_ = (capacity() - n) / 2;
		}
		fill_n(begin(), n, t);
		size_ = n;
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::allocator_type
	deque<void*, Allocator>::get_allocator() const
	{
		return alloc_;
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::iterator
	deque<void*, Allocator>::begin()
	{
		return make_iterator(start_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::const_iterator
	deque<void*, Allocator>::begin() const
	{
		return make_iterator(start_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::iterator
	deque<void*, Allocator>::end()
	{	
		return make_iterator(start_ + size_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::const_iterator
	deque<void*, Allocator>::end() const
	{	
		return make_iterator(start_ + size_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::reverse_iterator
	deque<void*, Allocator>::rbegin()
	{
		return reverse_iterator(end());
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::const_reverse_iterator
	deque<void*, Allocator>::rbegin() const
	{
		return const_reverse_iterator(end());
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::reverse_iterator
	deque<void*, Allocator>::rend()
	{
		return reverse_iterator(begin());
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::const_reverse_iterator
	deque<void*, Allocator>::rend() const
	{
		return const_reverse_iterator(begin());
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::size_type
	deque<void*, Allocator>::size() const
	{
		return size_;
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::size_type
	deque<void*, Allocator>::max_size() const
	{
		return alloc_.max_size();
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::resize(size_type sz, value_type c)
	{
		if (sz > size())
			insert(end(), sz-size(), c);
		else if (sz < size())
			erase(begin() + difference_type(sz), end());
	}

	template <class Allocator>
	inline
	bool
	deque<void*, Allocator>::empty() const
	{
		return size_ == 0;
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::reference
	deque<void*, Allocator>::operator[](size_type n)
	{
		size_type i = n + start_;
		return *(buf_[i / alloc_.m_] + i % alloc_.m_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::const_reference
	deque<void*, Allocator>::operator[](size_type n) const
	{
		size_type i = n + start_;
		return *(buf_[i / alloc_.m_] + i % alloc_.m_);
	}

	template <class Allocator>
	typename deque<void*, Allocator>::reference
	deque<void*, Allocator>::at(size_type n)
	{
		if (n >= size_)
			#ifndef _MSL_NO_EXCEPTIONS
				throw out_of_range("deque::at index out of range");
			#else
			{
				fprintf(stderr, "deque::at index out of range");
				abort();
			}
			#endif
		size_type i = n + start_;
		return *(buf_[i / alloc_.m_] + i % alloc_.m_);
	}

	template <class Allocator>
	typename deque<void*, Allocator>::const_reference
	deque<void*, Allocator>::at(size_type n) const
	{
		if (n >= size_)
			#ifndef _MSL_NO_EXCEPTIONS
				throw out_of_range("deque::at index out of range");
			#else
			{
				fprintf(stderr, "deque::at index out of range");
				abort();
			}
			#endif
		size_type i = n + start_;
		return *(buf_[i / alloc_.m_] + i % alloc_.m_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::reference
	deque<void*, Allocator>::front()
	{
		return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::const_reference
	deque<void*, Allocator>::front() const
	{
		return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::reference
	deque<void*, Allocator>::back()
	{
		size_type i = start_ + size_ - 1;
		return *(buf_[i / alloc_.m_] + i % alloc_.m_);
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::const_reference
	deque<void*, Allocator>::back() const
	{
		size_type i = start_ + size_ - 1;
		return *(buf_[i / alloc_.m_] + i % alloc_.m_);
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::push_front(const value_type& x)
	{
		if (size_ > max_size() - 1)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::push_front length error");
			#else
			{
				fprintf(stderr, "deque::push_front length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		if (start_ == 0)
			grow_buf_front(1);
		else
			--start_;
		if (start_ < alloc_.m_)
			*(buf_.front() + start_) = x;
		else
			*(buf_[start_ / alloc_.m_] + start_ % alloc_.m_) = x;
		++size_;
		invalidate_iterators();
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::push_back(const value_type& x)
	{
		if (size_ > max_size() - 1)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::insert length error");
			#else
			{
				fprintf(stderr, "deque::insert length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		{
			if (capacity() == start_ + size_)
				grow_buf_back(0, 1);
			size_type pos = start_ + size_;
			if (pos < alloc_.m_)
				*(buf_.front() + pos) = x;
			else
				*(buf_[pos / alloc_.m_] + pos % alloc_.m_) = x;
			++size_;
		}
		invalidate_iterators();
	}

	template <class Allocator>
	typename deque<void*, Allocator>::iterator
	deque<void*, Allocator>::insert(iterator position, const value_type& x)
	{
		difference_type pos = position - begin();
		insert(position, 1, x);
		return begin() + pos;
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::insert(iterator position, size_type n, const value_type& x)
	{
		if (n == 0)
			return;
		size_type ms = max_size();
		if (n > ms || size_ > ms - n)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("deque::insert length error");
			#else
			{
				fprintf(stderr, "deque::insert length error\n");
				abort();
			}
			#endif
		if (buf_.empty())
			init_buf();
		size_type pb = position.pos_ - start_;
		size_type pe = size_ - pb;
		if (pb <= pe)  // hh 981210
		{
			size_type new_buffers = 0;
			size_type oldstart = start_;
			if (start_ < n)
				grow_buf_front(n);
			else
				start_ -= n;
			if (pb == 0) // insert at begin()
				fill_n(begin(), n, x);
			else // pos in [1, size_ / 2)
			{
				iterator b = begin();
				copy(b + difference_type(n), b + difference_type(n + pb), b);
				fill_n(b + difference_type(pb), n, x);
			}
			size_ += n;
		}
		else // pos >= size_ / 2
		{
			size_type e = capacity() - (start_ + size_);
			if (e < n)
				grow_buf_back(e, n);
			if (pe == 0) // insert at end()
				fill_n(end(), n, x);
			else // pos in [size_ / 2, size_)
			{
				iterator e = end();
				iterator p = e - difference_type(pe);
				copy_backward(p, e, e + difference_type(n));
				fill_n(p, n, x);
			}
			size_ += n;
		}
		invalidate_iterators();
	}

	template <class Allocator>
	inline
	void
	deque<void*, Allocator>::pop_front()
	{
		++start_;
		if (--size_ == 0)
		{
			for (size_type i = buf_.size() - 2; i > 0; --i)
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
			start_ = alloc_.m_ / 2;
		}
	}

	template <class Allocator>
	inline
	void
	deque<void*, Allocator>::pop_back()
	{
		--size_;
		while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)
		{
			buf_.pop_back();
			pointer& p = buf_.back();
			alloc_.deallocate(p, alloc_.m_);
			p = 0;
		}
		if (size_ == 0)
		{
			for (size_type i = buf_.size() - 2; i > 0; --i)
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
			start_ = alloc_.m_ / 2;
		}
	}

	template <class Allocator>
	inline
	typename deque<void*, Allocator>::iterator
	deque<void*, Allocator>::erase(iterator position)
	{
		return erase(position, position + 1);
	}

	template <class Allocator>
	typename deque<void*, Allocator>::iterator
	deque<void*, Allocator>::erase(iterator first, iterator last)
	{
		if (first == last)
			return first;
		const size_type pb = first.pos_ - start_;
		const size_type pe = size_ - (last.pos_ - start_);
		const size_type diff = size_type(last - first);
		if (pb < pe)
		{
			if (pb == 0)  // erase from beginning, no copying necessary
			{
				start_ += diff;
				size_ -= diff;
			}
			else  // erase from beginning, needs copying
			{
				copy_backward(begin(), first, last);
				start_ += diff;
				size_ -= diff;
				invalidate_iterators();
			}
		}
		else  // pb >= pe - erase from end
		{
			if (pe != 0)  // erase from end, needs copying
			{
				copy(last, end(), first);
				invalidate_iterators();
			}
			size_ -= diff;
			while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
		}
		if (size_ == 0)
		{
			for (size_type i = buf_.size() - 1; i > 0; --i)
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
			start_ = alloc_.m_ / 2;
		}
		return make_iterator(start_ + pb);
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::swap(deque& x)
	{
		if (this != &x)
		{
			_STD::swap(alloc_, x.alloc_);
			_STD::swap(buf_, x.buf_);
			_STD::swap(start_, x.start_);
			_STD::swap(size_, x.size_);
		}
	}

	template <class Allocator>
	void
	deque<void*, Allocator>::clear()
	{
		if (!buf_.empty())  // hh 981209
		{
			size_ = 0;
			for (size_type i = buf_.size() - 2; i > 0; --i)
			{
				buf_.pop_back();
				pointer& p = buf_.back();
				alloc_.deallocate(p, alloc_.m_);
				p = 0;
			}
			start_ = alloc_.m_ / 2;
		}
	}

	template <class Allocator>
	inline
	bool
	operator==(const deque<void*,Allocator>& x, const deque<void*,Allocator>& y)
	{
		return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
	}

	template <class Allocator>
	inline
	bool
	operator!=(const deque<void*,Allocator>& x, const deque<void*,Allocator>& y)
	{
		return !(x == y);
	}

	template <class Allocator>
	inline
	bool
	operator< (const deque<void*,Allocator>& x, const deque<void*,Allocator>& y)
	{
		return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
	}

	template <class Allocator>
	inline
	bool
	operator> (const deque<void*,Allocator>& x, const deque<void*,Allocator>& y)
	{
		return y < x;
	}

	template <class Allocator>
	inline
	bool
	operator>=(const deque<void*,Allocator>& x, const deque<void*,Allocator>& y)
	{
		return !(x < y);
	}

	template <class Allocator>
	inline
	bool
	operator<=(const deque<void*,Allocator>& x, const deque<void*,Allocator>& y)
	{
		return !(y < x);
	}

	template <class Allocator>
	inline
	void
	swap(deque<void*,Allocator>& x, deque<void*,Allocator>& y)
	{
		x.swap(y);
	}

	// T*

	template <class T, class Allocator>
	class deque<T*, Allocator>
		: private deque<void*, Allocator::rebind<void*>::other>
	{
		typedef deque<void*, Allocator::rebind<void*>::other> base;
		typedef base::allocator_type base_allocator;
	public:
		// types:
		typedef typename Allocator::reference         reference;
		typedef typename Allocator::const_reference   const_reference;
		class                                         iterator;
		class                                         const_iterator;
		typedef typename Allocator::size_type         size_type;
		typedef typename Allocator::difference_type   difference_type;
		typedef T*                                    value_type;
		typedef Allocator                             allocator_type;
		typedef typename Allocator::pointer           pointer;
		typedef typename Allocator::const_pointer     const_pointer;
		typedef _STD::reverse_iterator<iterator>       reverse_iterator;
		typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;

		class iterator
			: public _STD::iterator<random_access_iterator_tag, value_type,
				difference_type, pointer, reference>
		{
		public:
			iterator() {}
			explicit iterator(const base::iterator& i) : i_(i) {}
			operator base::iterator() const {return i_;}
			reference operator * () const {return reference(*i_);}
			pointer operator -> () const {return pointer(i_.operator->());}
			iterator& operator ++ () {++i_; return *this;}
			iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}
			iterator& operator -- () {--i_; return *this;}
			iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}
			iterator& operator += (difference_type n) {i_ += n; return *this;}
			iterator operator + (difference_type n) const {return iterator(*this) += n;}
			iterator& operator -= (difference_type n) {i_ -= n; return *this;}
			iterator operator - (difference_type n) const {return iterator(*this) -= n;}
			difference_type operator - (const iterator& rhs) const {return i_ - rhs.i_;}
			reference operator [] (size_type i) const {return reference(i_[i]);}
			bool operator ==(const iterator& rhs) const {return i_ == rhs.i_;}
			bool operator !=(const iterator& rhs) const {return i_ != rhs.i_;}
			bool operator < (const iterator& rhs) const {return i_ <  rhs.i_;}
			bool operator <=(const iterator& rhs) const {return i_ <= rhs.i_;}
			bool operator > (const iterator& rhs) const {return i_ >  rhs.i_;}
			bool operator >=(const iterator& rhs) const {return i_ >= rhs.i_;}
			friend iterator operator + (difference_type n, const iterator& rhs)
				{return iterator(rhs) += n;}
		private:
			base::iterator i_;

			friend class deque::const_iterator;
		};

		class const_iterator
			: public _STD::iterator<random_access_iterator_tag, value_type,
				difference_type, const_pointer, const_reference>
		{
		public:
			const_iterator() {}
			const_iterator(const deque::iterator& rhs) : i_(rhs.i_) {}
			explicit const_iterator(const base::const_iterator& i) : i_(i) {}
			operator base::const_iterator() const {return i_;}
			const_reference operator * () const {return const_reference(*i_);}
			const_pointer operator -> () const {return const_pointer(i_.operator->());}
			const_iterator& operator ++ () {++i_; return *this;}
			const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}
			const_iterator& operator -- () {--i_; return *this;}
			const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}
			const_iterator& operator += (difference_type n) {i_ += n; return *this;}
			const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}
			const_iterator& operator -= (difference_type n) {i_ -= n; return *this;}
			const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}
			difference_type operator - (const const_iterator& rhs) const {return i_ - rhs.i_;}
			const_reference operator [] (size_type i) const {return const_reference(i_[i]);}
			bool operator ==(const const_iterator& rhs) const {return i_ == rhs.i_;}
			bool operator !=(const const_iterator& rhs) const {return i_ != rhs.i_;}
			bool operator < (const const_iterator& rhs) const {return i_ <  rhs.i_;}
			bool operator <=(const const_iterator& rhs) const {return i_ <= rhs.i_;}
			bool operator > (const const_iterator& rhs) const {return i_ >  rhs.i_;}
			bool operator >=(const const_iterator& rhs) const {return i_ >= rhs.i_;}
			friend const_iterator operator + (difference_type n, const const_iterator& rhs)
				{return const_iterator(rhs) += n;}
		private:
			base::const_iterator i_;
		};

		// _lib.deque.cons_ construct/copy/destroy:
		explicit deque(const Allocator& = Allocator());
		explicit deque(size_type n, const value_type& value = 0, const Allocator& = Allocator());
		template <class InputIterator>
			inline
			deque(InputIterator first, InputIterator last, const Allocator& a = Allocator())
				: base(first, last, base_allocator(a))
			{
			}
		template <class InputIterator>
			inline
			void assign(InputIterator first, InputIterator last)
			{
				base::assign(first, last);
			}
		void assign(size_type n, const value_type& t);
		allocator_type get_allocator() const;
		// iterators:
		iterator               begin();
		const_iterator         begin() const;
		iterator               end();
		const_iterator         end() const;
		reverse_iterator       rbegin();
		const_reverse_iterator rbegin() const;
		reverse_iterator       rend();
		const_reverse_iterator rend() const;
		// _lib.deque.capacity_ capacity:
		size_type size() const;
		size_type max_size() const;
		void      resize(size_type sz, value_type c = 0);
		bool      empty() const;

		// element access:
		reference       operator[](size_type n);
		const_reference operator[](size_type n) const;
		reference       at(size_type n);
		const_reference at(size_type n) const;
		reference       front();
		const_reference front() const;
		reference       back();
		const_reference back() const;
		// _lib.deque.modifiers_ modifiers:
		void push_front(const value_type& x);
		void push_back(const value_type& x);
		iterator insert(iterator position, const value_type& x);
		void     insert(iterator position, size_type n, const value_type& x);
		template <class InputIterator>
			void insert(iterator position, InputIterator first, InputIterator last)
			{
				base::insert(position, first, last);
			}
		void pop_front();
		void pop_back();
		iterator erase(iterator position);
		iterator erase(iterator first, iterator last);
		void     swap(deque&);
		void     clear();
	};

	// Implementation deque<T*>

	template <class T, class Allocator>
	inline
	deque<T*, Allocator>::deque(const Allocator& a)
		: base(base_allocator(a))
	{
	}

	template <class T, class Allocator>
	inline
	deque<T*, Allocator>::deque(size_type n, const value_type& value, const Allocator& a)
		: base(n, value, base_allocator(a))
	{
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::assign(size_type n, const value_type& t)
	{
		base::assign(n, t);
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::allocator_type
	deque<T*, Allocator>::get_allocator() const
	{
		return base::get_allocator();
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::iterator
	deque<T*, Allocator>::begin()
	{
		return iterator(base::begin());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_iterator
	deque<T*, Allocator>::begin() const
	{
		return const_iterator(base::begin());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::iterator
	deque<T*, Allocator>::end()
	{	
		return iterator(base::end());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_iterator
	deque<T*, Allocator>::end() const
	{	
		return const_iterator(base::end());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::reverse_iterator
	deque<T*, Allocator>::rbegin()
	{
		return reverse_iterator(end());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_reverse_iterator
	deque<T*, Allocator>::rbegin() const
	{
		return const_reverse_iterator(end());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::reverse_iterator
	deque<T*, Allocator>::rend()
	{
		return reverse_iterator(begin());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_reverse_iterator
	deque<T*, Allocator>::rend() const
	{
		return const_reverse_iterator(begin());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::size_type
	deque<T*, Allocator>::size() const
	{
		return base::size();
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::size_type
	deque<T*, Allocator>::max_size() const
	{
		return base::max_size();
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::resize(size_type sz, value_type c)
	{
		base::resize(sz, c);
	}

	template <class T, class Allocator>
	inline
	bool
	deque<T*, Allocator>::empty() const
	{
		return base::empty();
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::reference
	deque<T*, Allocator>::operator[](size_type n)
	{
		return reference(base::operator[](n));
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_reference
	deque<T*, Allocator>::operator[](size_type n) const
	{
		return const_reference(base::operator[](n));
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::reference
	deque<T*, Allocator>::at(size_type n)
	{
		return reference(base::at(n));
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_reference
	deque<T*, Allocator>::at(size_type n) const
	{
		return const_reference(base::at(n));
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::reference
	deque<T*, Allocator>::front()
	{
		return reference(base::front());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_reference
	deque<T*, Allocator>::front() const
	{
		return const_reference(base::front());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::reference
	deque<T*, Allocator>::back()
	{
		return reference(base::back());
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::const_reference
	deque<T*, Allocator>::back() const
	{
		return const_reference(base::back());
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::push_front(const value_type& x)
	{
		base::push_front(x);
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::push_back(const value_type& x)
	{
		base::push_back(x);
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::iterator
	deque<T*, Allocator>::insert(iterator position, const value_type& x)
	{
		return iterator(base::insert(position, x));
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::insert(iterator position, size_type n, const value_type& x)
	{
		base::insert(position, n, x);
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::pop_front()
	{
		base::pop_front();
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::pop_back()
	{
		base::pop_back();
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::iterator
	deque<T*, Allocator>::erase(iterator position)
	{
		return iterator(base::erase(position));
	}

	template <class T, class Allocator>
	inline
	typename deque<T*, Allocator>::iterator
	deque<T*, Allocator>::erase(iterator first, iterator last)
	{
		return iterator(base::erase(first, last));
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::swap(deque& x)
	{
		base::swap((base&)x);
	}

	template <class T, class Allocator>
	inline
	void
	deque<T*, Allocator>::clear()
	{
		base::clear();
	}

	template <class T, class Allocator>
	inline
	bool
	operator==(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)
	{
		return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
	}

	template <class T, class Allocator>
	inline
	bool
	operator!=(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)
	{
		return !(x == y);
	}

	template <class T, class Allocator>
	inline
	bool
	operator< (const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)
	{
		return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
	}

	template <class T, class Allocator>
	inline
	bool
	operator> (const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)
	{
		return y < x;
	}

	template <class T, class Allocator>
	inline
	bool
	operator>=(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)
	{
		return !(x < y);
	}

	template <class T, class Allocator>
	inline
	bool
	operator<=(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)
	{
		return !(y < x);
	}

	template <class T, class Allocator>
	inline
	void
	swap(deque<T*,Allocator>& x, deque<T*,Allocator>& y)
	{
		x.swap(y);
	}

#endif // !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)

#ifndef _MSL_NO_CPP_NAMESPACE
	} // namespace std
#endif

#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)
	#pragma import reset
#endif
#pragma options align=reset

#endif // RC_INVOKED

#endif // _DEQUE

// hh 971220 fixed MOD_INCLUDE
// hh 971221 Changed filename from deque.h to deque
// hh 971221 Made include guards standard
// hh 971221 Added qualified name to const_iterator
// hh 971221 Added qualified name to iterator
// hh 971230 added RC_INVOKED wrapper
// hh 980105 changed pointer & reference to const versions in const_iterator base class
// hh 980105 rewrote some constructors to get rid of unused arg dq warning
// hh 980111 <string> added so deque could throw a stdexcept
// hh 980111 made at and operator[] standard compliant
// hh 980713 Temporarily moved member templates into class definition to support compiler
// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT
// hh 981027 rewrote
// hh 981208 changed static_cast to reinterpret_cast on the value_type (pointer specialization only)
// hh 981209 Protected clear() from an empty buf_
// hh 981210 Modified insertion into front half to preserve outstanding iterators under exceptions
//           and made it more efficient when the initial size is zero.
// hh 981210 Added forgotten for loop in insert
// hh 981220 Rewrote iterators to gain higher performance
// hh 981220 Added typename to appropriate return types
// hh 981220 Modifed some method signitures to simplified syntax
// hh 981220 Added class modifier to several friend declarations
// hh 990120 changed name of MSIPL flags
// hh 990315 Fix a bug when deallocating buffer during an exception