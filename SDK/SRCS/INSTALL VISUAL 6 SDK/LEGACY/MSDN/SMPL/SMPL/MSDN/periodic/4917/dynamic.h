#ifndef DYNAMIC_H__
#define DYNAMIC_H__

#include <stdio.h>
#include <string.h>
#include <typeinfo.h>
//----------------------------------------------------------------------
// 			(C) 1996, Allen I. Holub. All rights reserved.
//----------------------------------------------------------------------
// Support for polymorphic persistence. There's an example in the 
// implemenation file (/src/tools.cpp/persist.cpp).
//
// Under Microsoft compiler, must be compiled with /Gr switch:
// Under Settings, "C/C++" tab, "C++ Language" catagory
//					check "Enable run-time type information"
//
// Dynamically-creatable objects must have a default constructor
// and at least one virtual function, usually the destructor.
//
namespace dynamic
{
	void *create( const char *cls_name );
	//------------------------------------------------------------------
	class abstract_factory
	{
	public:
		virtual void *create_obj( const char *class_name ) = 0;
	};
	//------------------------------------------------------------------
	class factory_list_ele
	{
		friend void *create( const char *cls_name );
	
		static factory_list_ele	*head;
		factory_list_ele		*next;
		abstract_factory		*manufacturer;
	public:
		factory_list_ele( abstract_factory *fact );
		virtual ~factory_list_ele( void );

	};
	//------------------------------------------------------------------
	inline factory_list_ele::factory_list_ele(  abstract_factory *fact )
							: manufacturer( fact )
	{
		next = head;
		head = this;
	}
	//------------------------------------------------------------------
	// disable Warning C4355: "'this' used in base member initializer
	// list." The warning is generated by the initialzation list of the
	// factory<t> constructor. The warning is noise in the current context,
	// because "manufacturer" is not actually a base class. The pragma
	// must be at the global level because the warning is kicked out
	// every time the template is expanded.

	#pragma	warning(disable : 4355)
	//------------------------------------------------------------------
	// The "manufacturer" field isn't static because I want to initialize
	// it in the constructor. This way I can avoid having to define one
	// for every template expansion. This means that you might have more
	// than one manufacturer for a given class (if you declare several
	// factories for the same class, for example), but it's a harmless
	// error.

	template <class t>
	class factory: public abstract_factory
	{
		static t		 an_object;
		factory_list_ele manufacturer;
													  
	public:
		factory( void ): manufacturer( this ) {}

		void *create_obj( const char *class_name )
		{
			return !strcmp( typeid(an_object).name(), class_name)
					? (void*)( new t )
					: 0
					;
		}
	};
}
#endif // DYNAMIC_H__